                ;
                ; BDOS	CP/M REV. 2.2
                ;
 0014 =         MSIZE	EQU  20		;MEMORY SIZE
 3C00 =         DOSLOC	EQU  (MSIZE-20)*1024+3C00H	;WHERE BDOS RESIDES
                ;DOSLOC	EQU  (MSIZE-20)*1024+3500H	;WHERE TT BDOS RESIDES
                ;
 0000 =         BOOTV	EQU  0000H	;VECTOR TO BIOS WARM BOOT ROUTINE
 0003 =         IOBYTE	EQU  0003H	;SYSTEM I/O DEVICE ASSIGNMENT
 0080 =         TBUFF	EQU  0080H	;DEFAULT DMA BUFFER LOCATION
                ;
 0000 =         FALSE	EQU	0		;
 0001 =         TRUE	EQU	1		;
                ;
 000D =         CR	EQU	0DH		;
 000A =         LF	EQU	0AH		;
 0009 =         TAB	EQU	09H		;TAB
 0008 =         BACKSP	EQU	08H		;BACKSPACE
 0003 =         CTRLC	EQU	03H		;CONTROL-C
 0005 =         CTRLE	EQU	05H		;CONTROL-E
 0010 =         CTRLP	EQU	10H		;CONTROL-P
 0012 =         CTRLR	EQU	12H		;CONTROL-R
 0013 =         CTRLS	EQU	13H		;CONTROL-S
 0015 =         CTRLU	EQU	15H		;CONTROL-U
 0018 =         CTRLX	EQU	18H		;CONTROL-X
 00E5 =         DELDAT	EQU	0E5H		;DELETED DATA BYTE
                ;
 3C00           	ORG	DOSLOC
                ;
 3C00 000000    SERIAL:	DB	0,0,0		;ROOM FOR SERIAL NUMBER
 3C03 000000    	DB	0,0,0
                ;
                ;************************************************************
                ;BDOS ENTRY POINT. DATA ENTERS AS FOLLOWS:
                ;		C  = COMMAND
                ;		DE = ADDRESS OR 16 BIT DATA WORD
                ;		E  = 8 BIT DATA WORD
                ;
                ;      RETURN FROM BDOS DATA IS AS FOLLOWS:
                ;		A  = STATUS OR VALUE
                ;		HL = 16 BIT VALUE OR ADDRESS
                ;
 3C06 C3113C    ENTRY:	JMP	BDOS		;ENTRY TO DISK MONITOR
                ;
                ;******************************************************************************
                ; BDOS ERROR MESSAGE TABLE - USED BY OTHER CP/M UTILITIES PERHAPS
                ;
 3C09 993C      PERERR:	DW	PERSUB		;PERMANENT ERROR SUBROUTINE
 3C0B A53C      SELERR:	DW	SELSUB		;SELECT ERROR SUBROUTINE
 3C0D AB3C      ROERR:	DW	ROSUB		;READ-ONLY SUBROUTINE
 3C0F B13C      RONERR:	DW	RONSUB		;READ-ONLY ERROR SUBROUTINE
                ;
                ;******************************************************************************
                ;BDOS ENTRY SAVES INPUT DATA AS FOLLOWS:
                ;    DE -> FCB		0  -> OLDDSK
                ;    E  -> IDATA	0  -> OUT1
                ;    0  -> ODATA	SETS RETURN TO BEXIT ON STACK
                ;    SP -> OLDSP
                ;    
                ;    SAVES INPUT DATA AND JUMPS TO COMMAND ROUTINE
                ;
 3C11 EB        BDOS:	XCHG			;SWAP DE AND HL - ENTRY FCB IS NOW IN HL
 3C12 22433F    	SHLD	FCB		;SAVE DATA IN FCB FOR NOW
 3C15 EB        	XCHG			;PUT REGISTERS BACK
 3C16 7B        	MOV	A,E		;MOVE DATA BYTE INTO A
 3C17 32D649    	STA	IDATA		;SAVE IT 
 3C1A 210000    	LXI	H,0		;ZERO OUT HL
 3C1D 22453F    	SHLD	ODATA		;SAVE THIS FOR THE RETURN
 3C20 39        	DAD	SP		;ADD IN THE USER STACK POINTER
 3C21 220F3F    	SHLD	OLDSP		;SAVE THIS FOR THE RETURN ALSO
 3C24 31413F    	LXI	SP,USRCOD	;POINT TO BDOS STACK
 3C27 AF        	XRA	A		;ZERO OUT A
 3C28 32E049    	STA	OLDDSK		;SAVE THIS AS THE OLD DISK
 3C2B 32DE49    	STA	OUT1		;AND AT OUT1 FOR DISK RELOG ON EXIT
 3C2E 217449    	LXI	H,BEXIT		;GET THE RETURN POINT ADDRESS
 3C31 E5        	PUSH	H		;AND STUFF IT ON THE STACK FOR EXITING
 3C32 79        	MOV	A,C		;MOVE THE COMMAND INTO A
 3C33 FE29      	CPI	41		;MAX CMDS +1 - IS IT TOO BIG?
 3C35 D0        	RNC			;RETURN IF SO
 3C36 4B        	MOV	C,E		;GET INPUT DATA FROM E INTO C
 3C37 21473C    	LXI	H,DISTBL	;POINT TO THE DISPATCH TABLE
 3C3A 5F        	MOV	E,A		;MOVE THE COMMAND FROM A INTO E
 3C3B 1600      	MVI	D,0		;ZERO OUT D
 3C3D 19        	DAD	D		;ADD IN THE DISPATCH TABLE
 3C3E 19        	DAD	D		;ONCE MORE - OVER TWO BYTES
 3C3F 5E        	MOV	E,M		;PULL THE JUMP ADDRESS
 3C40 23        	INX	H		;  INTO
 3C41 56        	MOV	D,M		;    DE
 3C42 2A433F    	LHLD	FCB		;GET THE INFO WORD INTO HL
 3C45 EB        	XCHG			;SWAP DE AND HL
 3C46 E9        	PCHL			;JUMP TO THE COMMAND ROUTINE
                ;
                ;******************************************************************************
                ; COMMAND DISPATCH TABLE
                ;
 3C47 034A      DISTBL:	DW	WBOOTF		; 0: SYSTEM RESET
 3C49 C83E      	DW	REDCON		; 1: CONSOLE INPUT
 3C4B 903D      	DW	WRTCON		; 2: CONSOLE OUTPUT
 3C4D CE3E      	DW	REDRDR		; 3: READER INPUT
 3C4F 124A      	DW	PUNF		; 4: PUNCH OUTPUT
 3C51 0F4A      	DW	LISTF		; 5: LIST OUTPUT
 3C53 D43E      	DW	DIRTIO		; 6: DIRECT CONSOLE I/O
 3C55 ED3E      	DW	GETIOB		; 7: GET I/O BYTE
 3C57 F33E      	DW	PUTIOB		; 8: SET I/O BYTE
 3C59 F83E      	DW	PRNBUF		; 9: PRINT STRING
 3C5B E13D      	DW	REDBUF		;10: READ CONSOLE BUFFER
 3C5D FE3E      	DW	GCSTAT		;11: GET CONSOLE STATUS
 3C5F 7E48      	DW	GETVER		;12: RETURN VERSION NUMBER
 3C61 8348      	DW	RESET		;13: RESET DISK SYSTEM
 3C63 4548      	DW	LOGIN		;14: SELECT DISK
 3C65 9C48      	DW	OPEN		;15: OPEN FILE
 3C67 A548      	DW	CLOSE		;16: CLOSE FILE
 3C69 AB48      	DW	SEAR1		;17: SEARCH FOR FIRST
 3C6B C848      	DW	SEARN		;18: SEARCH FOR NEXT
 3C6D D748      	DW	DELETE		;19: DELETE FILE
 3C6F E048      	DW	READ		;20: READ SEQUENTIAL
 3C71 E648      	DW	WRITE		;21: WRITE SEQUENTIAL
 3C73 EC48      	DW	CREATE		;22: MAKE FILE
 3C75 F548      	DW	RENAME		;23: RENAME FILE
 3C77 FE48      	DW	GLOGIN		;24: RETURN LOGIN VECTOR
 3C79 0449      	DW	GETDRV		;25: RETURN CURRENT DISK
 3C7B 0A49      	DW	DMASET		;26: SET DMA ADDRESS
 3C7D 1149      	DW	GALLOC		;27: GET ADDR (ALLOC)
 3C7F 2C41      	DW	MAKRO		;28: WRITE PROTECT DISK
 3C81 1749      	DW	GROVEC		;29: GET R/O VECTOR
 3C83 1D49      	DW	SETATT		;30: SET FILE ATTRIBUTES
 3C85 2649      	DW	GETPAR		;31: GET ADDR (DISK PARMS)
 3C87 2D49      	DW	MODUSR		;32: SET/GET USER CODE
 3C89 4149      	DW	REDRND		;33: READ RANDOM
 3C8B 4749      	DW	WRTRND		;34: WRITE RANDOM
 3C8D 4D49      	DW	FILSIZ		;35: COMPUTE FILE SIZE
 3C8F 0E48      	DW	SETRND		;36: SET RANDOM RECORD
 3C91 5349      	DW	RESDRV		;37: RESET DRIVE
 3C93 043F      	DW	JR		;38: UNDEFINED - GO BACK
 3C95 043F      	DW	JR		;39: UNDEFINED - GO BACK
 3C97 9B49      	DW	ZERRND		;40: FILL RANDOM FILE W/ ZEROS
                ;
                ;******************************************************************************
                ; PRINT THE PERMANENT ERROR MESSAGE
                ;
 3C99 21CA3C    PERSUB:	LXI	H,PERMSG	;POINT TO BAD SECTOR MESSAGE
 3C9C CDE53C    	CALL	DOSERR		;PRINT OUT WITH DISK AND RETURN
 3C9F FE03      	CPI	CTRLC		;RETURN WITH A CHAR - IS IT CTRLC?
 3CA1 CA0000    	JZ	BOOTV		;IF SO GO REBOOT
 3CA4 C9        	RET			;OTHERWISE JUST GO BACK
                ;
                ;******************************************************************************
                ; PRINT THE SELECT ERROR MESSAGE THEN DIE
                ;
 3CA5 21D53C    SELSUB:	LXI	H,SELMSG	;'SELECT' MSG
 3CA8 C3B43C    	JMP	BOMB		;SAY TOO BAD THEN ABORT
                ;
                ;******************************************************************************
                ; PRINT READ ONLY ERROR MESSAGE THEN DIE
 3CAB 21E13C    ROSUB:	LXI	H,ROMSG		;SEND R/O MSG
 3CAE C3B43C    	JMP	BOMB		; SAY TOO BAD THEN ABORT
                ;
                ;******************************************************************************
                ; PRINT FILE READ-ONLY ERROR MESSAGE, DIE
                ;
 3CB1 21DC3C    RONSUB:	LXI	H,ROEMSG	;'FILE R/O' MSG
                ;
                ;******************************************************************************
                ; PRINT OUT THE ERROR MESSAGE THEN REBOOT
                ;
 3CB4 CDE53C    BOMB:	CALL	DOSERR		;PRINT BDOS ERR ON [DSK #]
 3CB7 C30000    	JMP	BOOTV		;REBOOT SYSTEM
                ;
                ;******************************************************************************
                ; ERROR MESSAGES
                ;
 3CBA 42646F7320DOSMSG:	DB	'Bdos Err On '
 3CC6 203A2024  DSKCH:	DB	' : $'
 3CCA 4261642053PERMSG:	DB	'Bad Sector$'
 3CD5 53656C6563SELMSG:	DB	'Select$'
 3CDC 46696C6520ROEMSG:	DB	'File '
 3CE1 522F4F24  ROMSG:	DB	'R/O$'
                ;
                ;******************************************************************************
                ; PRINT BDOS ERROR MSG WITH DISK #
                ;
 3CE5 E5        DOSERR:	PUSH	H		;SAVE THE MESSAGE POINTER
 3CE6 CDC93D    	CALL	CRLF		;TURN UP A NEW LINE
 3CE9 3A423F    	LDA	CURDSK		;GET THE CURRENT DISK
 3CEC C641      	ADI	'A'		;ADD IN THE ASCII BIAS
 3CEE 32C63C    	STA	DSKCH		;FORM DRIVE ID CHAR
 3CF1 01BA3C    	LXI	B,DOSMSG	;PRINT THE
 3CF4 CDD33D    	CALL	PRINT		; 'BDOS ERR ON' MSG
 3CF7 C1        	POP	B		;RESTORE THE MESSAGE POINTER
 3CF8 CDD33D    	CALL	PRINT		;PRINT SPECIFIC ERROR MESSAGE
                ;
                ;******************************************************************************
                ; READ NEXT CONSOLE CHARACTER
                ;
 3CFB 210E3F    CONIN:	LXI	H,CHRRDY	;POINT TO THE CHAR READY FLAG
 3CFE 7E        	MOV	A,M		;MOVE THE READY BYTE INTO A
 3CFF 3600      	MVI	M,0		;AND ZERO OUT THE FLAG
 3D01 B7        	ORA	A		;WAS ANYONE HOME
 3D02 C0        	RNZ			;RETURN IF NOT
 3D03 C3094A    	JMP	CONIF		;OTHERWISE GO GET THE THING
                ;
                ;******************************************************************************
                ; READ CONSOLE CHARACTER, ECHO PRINT IF IT IS OK 
                ;
 3D06 CDFB3C    CIECHO:	CALL	CONIN		;GET A CHARACTER
 3D09 CD143D    	CALL	GRAFIC		;CHECK THE CONTROL CHARACTERS
 3D0C D8        	RC			;RETURN IF THE CHAR IS NOT PRINTABLE
 3D0D F5        	PUSH	PSW		;OTHERWISE SAVE IT
 3D0E 4F        	MOV	C,A		;PUT A COPY INTO C
 3D0F CD903D    	CALL	WRTCON		;AND PRINT IT OUT
 3D12 F1        	POP	PSW		;RESTORE IT
 3D13 C9        	RET			;AND RETURN TO SENDER
                ;
                ;******************************************************************************
                ;SEE IF A IS A GOOD CONTROL CHAR, RET WITH CY SET IF NOT
                ;
 3D14 FE0D      GRAFIC:	CPI	CR		;TEST FOR CARRIAGE RETURN
 3D16 C8        	RZ			;RETURN IF IT WAS
 3D17 FE0A      	CPI	LF		;HOW ABOUT LINE FEED
 3D19 C8        	RZ			;THAT IS OK
 3D1A FE09      	CPI	TAB		;AS IS TAB
 3D1C C8        	RZ			;SO BACK WITH IT
 3D1D FE08      	CPI	BACKSP		;BACKSPACE IN 2.0
 3D1F C8        	RZ			;IS KNOWN
 3D20 FE20      	CPI	' '		;TEST ALL OTHER CONTROL CHARACTERS
 3D22 C9        	RET			;AND GO BACK WITH CARRY SET FOR NO ECHO
                ;
                ;******************************************************************************
                ; CHECK FOR CONSOLE BREAK AND ABORT
                ;
 3D23 3A0E3F    CONBRK:	LDA	CHRRDY		;GET THE CHARACTER READY BYTE
 3D26 B7        	ORA	A		;AND CHECK FOR WAITING CHAR
 3D27 C2453D    	JNZ	CB1		;NON ZERO SAYS SOMETHING IS THERE
 3D2A CD064A    	CALL	CONSF		;CHECK THE CONSOLE IF NONE THERE
 3D2D E601      	ANI	01H		;AND IN THE STATUS BIT
 3D2F C8        	RZ			;RETURN IF IT CAME UP ZERO
 3D30 CD094A    	CALL	CONIF		;OTHERWISE GO GET THE WAITING CHAR
 3D33 FE13      	CPI	CTRLS		;WAS IT A CONTROL-S
 3D35 C2423D    	JNZ	CB0		;IF NOT RETURN WITH READY FLAG SET
 3D38 CD094A    	CALL	CONIF		;IF IT WAS WAIT FOR THE NEXT CHAR
 3D3B FE03      	CPI	CTRLC		;IS THIS ONE CONTROL C?
 3D3D CA0000    	JZ	BOOTV		;IF SO WE REBOOT
 3D40 AF        	XRA	A		;OR ELSE ZERO A
 3D41 C9        	RET			;AND SIMPLY RETURN
                ;
 3D42 320E3F    CB0:	STA	CHRRDY		;SAVE INPUT CHAR
 3D45 3E01      CB1:	MVI	A,TRUE		;AND SAY TRUE TO THE CALLER
 3D47 C9        	RET			;AND GO BACK
                ;
                ;******************************************************************************
                ; OUTPUT CHAR IN C TO CONSOLE, LIST ALSO IF LSTCPY = TRUE
                ;
 3D48 3A0A3F    CONOUT:	LDA	CTEMP1		;GET THE FIRST TEMP COLUMN COUNTER
 3D4B B7        	ORA	A		;IS IT ZERO?
 3D4C C2623D    	JNZ	CONOU1		;IF NONZERO JUMP OVER
 3D4F C5        	PUSH	B		;OTHERWISE SAVE INPUT CHARACTER
 3D50 CD233D    	CALL	CONBRK		;CHECK FOR ABORT
 3D53 C1        	POP	B		;RECOVER THE CHAR
 3D54 C5        	PUSH	B		;SAVE IT AGAIN
 3D55 CD0C4A    	CALL	CONOF		;AND PRINT THE CHARACTER ON THE CONSOLE
 3D58 C1        	POP	B		;RECOVER ONCE MORE
 3D59 C5        	PUSH	B		;WOULD YOU BELIEVE SAVE IT AGAIN
 3D5A 3A0D3F    	LDA	LSTCPY		;GET THE LIST FLAG BYTE
 3D5D B7        	ORA	A		;TO SET FLAGS
 3D5E C40F4A    	CNZ	LISTF		; AND TO LIST IF LSTCPY=TRUE
 3D61 C1        	POP	B		;RESTORE CHAR ONE LAST TIME
 3D62 79        CONOU1:	MOV	A,C		;PUT THE BYTE INTO A
 3D63 210C3F    	LXI	H,COLUMN	;POINT TO THE BUFFER COLUMN COUNTER
 3D66 FE7F      	CPI	7FH		;RUBOUT ?
 3D68 C8        	RZ			;RETURN IF SO
 3D69 34        	INR	M		;INCREMENT COLUMN
 3D6A FE20      	CPI	' '		;IS THE CHARACTER A SPACE?
 3D6C D0        	RNC			;RETURN IF LESS - MUST BE CONTROL
 3D6D 35        	DCR	M		;DECREMENT COLUMN
 3D6E 7E        	MOV	A,M		;AND GET THE CHARACTER THERE
 3D6F B7        	ORA	A		;CHECK FOR A NULL
 3D70 C8        	RZ			;RETURN IF IT IS
 3D71 79        	MOV	A,C		;MOVE THE CHAR INTO C
 3D72 FE08      	CPI	BACKSP		;WAS IT A BACKSPACE?
 3D74 C2793D    	JNZ	CONOU2		;IF NOT JUMP OVER
 3D77 35        	DCR	M		;DECREMENT COLUMN
 3D78 C9        	RET			;AND RETURN
                ;
 3D79 FE0A      CONOU2:	CPI	LF		;WAS IT A LINEFEED?
 3D7B C0        	RNZ			;RETURN IF NOT AGAIN
 3D7C 3600      	MVI	M,0		;SET COLUMN TO 0
 3D7E C9        	RET			;AND RETURN
                ;
                ;******************************************************************************
                ; PRINT CHAR IN C AT CONSOLE, CONVERT CTRL CHARS TO ^[CHAR]
                ;
 3D7F 79        CTLOUT:	MOV	A,C		;MOVE THE CHAR INTO A
 3D80 CD143D    	CALL	GRAFIC		;SEE IF IT IS PRINTABLE
 3D83 D2903D    	JNC	WRTCON		;JUMP PAST CAUSE IT IS OK
 3D86 F5        	PUSH	PSW		;OTHERWISE SAVE CTRL CHAR ON THE STACK
 3D87 0E5E      	MVI	C,5EH		;GET THE "^" CHAR
 3D89 CD483D    	CALL	CONOUT		;AND PRINT IT
 3D8C F1        	POP	PSW		;GET THE CHAR BACK
 3D8D F640      	ORI	40H		;ADD IN THE BIAS TO MAKE IT PRINT
 3D8F 4F        	MOV	C,A		;PUT IT INTO C FOR THE NEXT
                ;
                ;******************************************************************************
                ; BDOS FUNCTION 2: WRITE TO THE SYSTEM CONSOLE CHAR IN C
                ;
 3D90 79        WRTCON:	MOV	A,C		;WHICH PUTS IT INTO A
 3D91 FE09      	CPI	TAB		;CHECK FOR TAB
 3D93 C2483D    	JNZ	CONOUT		;IF NOT JUMP AND PRINT
 3D96 0E20      TABOUT:	MVI	C,' '		;SPACE GETS PRINTED TO EXPAND TABS
 3D98 CD483D    	CALL	CONOUT		; TO
 3D9B 3A0C3F    	LDA	COLUMN		;  NEXT
 3D9E E607      	ANI	07H		;   TAB
 3DA0 C2963D    	JNZ	TABOUT		;    STOP
 3DA3 C9        	RET			;RETURN
                ;
 3DA4 CDAC3D    DELAST:	CALL	BACKUP		;BACK UP ONE CHARACTER
 3DA7 0E20      	MVI	C,' '		;THEN GET A BLANK
 3DA9 CD0C4A    	CALL	CONOF		;AND PRINT IT OUT
 3DAC 0E08      BACKUP:	MVI	C,BACKSP	;GET A BACKSPACE
 3DAE C30C4A    	JMP	CONOF		;AND PRINT IT AS WELL TO MOVE INTO SPOT
                ;
                ;******************************************************************************
                ; PRINT POUND SIGN, CRLF, AND FIX COLUMNS
                ;
 3DB1 0E23      LBCRLF:	MVI	C,'#'		;GET A POUND SIGN
 3DB3 CD483D    	CALL	CONOUT		;AND PRINT IT
 3DB6 CDC93D    	CALL	CRLF		;TURN UP A NEW LINE
 3DB9 3A0C3F    LB1:	LDA	COLUMN		;GET THE COLUMN COUNTER
 3DBC 210B3F    	LXI	H,CTEMP2	;POINT TO THE TEMP COUNTER
 3DBF BE        	CMP	M		;ARE THEY EQUAL?
 3DC0 D0        	RNC			;NOT THERE YET
 3DC1 0E20      	MVI	C,' '		;SO GET A SPACE
 3DC3 CD483D    	CALL	CONOUT		;AND PRINT IT OUT
 3DC6 C3B93D    	JMP	LB1		;LOOP TIL THE COUNTS ARE THE SAME
                ;
                ;******************************************************************************
                ; PRINT CR/LF AT CONSOLE
                ;
 3DC9 0E0D      CRLF:	MVI	C,CR		; GET A CR
 3DCB CD483D    	CALL	CONOUT		;AND PRINT IT OUT
 3DCE 0E0A      	MVI	C,LF		;FOLLOWED BY A LF
 3DD0 C3483D    	JMP	CONOUT		;WHICH GOES OUT TOO
                ;
                ;******************************************************************************
                ; PRINT STRING AT (BC) UNTIL '$' WITH TAB EXPANSION
                ;
 3DD3 0A        PRINT:	LDAX	B		;GET THE BYTE AT (BC)
 3DD4 FE24      	CPI	'$'		;IS IT THE END MARK?
 3DD6 C8        	RZ			;IF SO WE ARE DONE
 3DD7 03        	INX	B		;OTHERWISE BUMP THE POINTER
 3DD8 C5        	PUSH	B		;AND SAVE IT IN THE STACK
 3DD9 4F        	MOV	C,A		;GET THE CHARACTER INTO C
 3DDA CD903D    	CALL	WRTCON		;WRITE IT OUT EXPANDING TABS
 3DDD C1        	POP	B		;RECOVER THE POINTER
 3DDE C3D33D    	JMP	PRINT		;AND LOOP TIL WE HIT THE STOP
                ;
                ;******************************************************************************
                ; BDOS FUNCTION 10: READ CONSOLE BUFFER AT 
                ;     ENTER WITH BC -> CONSOLE BUFFER ADDRESS
                ;
 3DE1 3A0C3F    REDBUF:	LDA	COLUMN		;GET THE COLUMN COUNTER INTO A
 3DE4 320B3F    	STA	CTEMP2		;SAVE IT AT CTEMP2
 3DE7 2A433F    	LHLD	FCB		;GET THE INFORMATION INTO HL
 3DEA 4E        	MOV	C,M		;GET THE BUFFER COUNT BYTE 
 3DEB 23        	INX	H		;AND BUMP THE POINTER TO THE NEXT SPOT
 3DEC E5        	PUSH	H		;SAVE IT FOR LATER
 3DED 0600      	MVI	B,0		;ZERO B
 3DEF C5        RB0:	PUSH	B		;SAVE BC FOR LATER
 3DF0 E5        	PUSH	H		;AND HL AS WELL
 3DF1 CDFB3C    RB1:	CALL	CONIN		;GO GET A CHAR FROM THE CONSOLE
 3DF4 E67F      	ANI	7FH		;STRIP THE PARITY BIT
 3DF6 E1        	POP	H		;RECOVER HL
 3DF7 C1        	POP	B		;AND BC
 3DF8 FE0D      	CPI	CR		;IS THIS CHARACTER A CR?
 3DFA CAC13E    	JZ	RBEXIT		;IF SO JUMP OVER
 3DFD FE0A      	CPI	LF		;HOW ABOUT A LF
 3DFF CAC13E    	JZ	RBEXIT		;JUMP WITH THAT AS WELL
 3E02 FE08      	CPI	BACKSP		;DO WE HAVE A BACKSPACE?
 3E04 C2163E    	JNZ	CHKRUB		;IF NOT OVER WE GO
 3E07 78        	MOV	A,B		;PUT B INTO A
 3E08 B7        	ORA	A		;IS IT STILL ZERO?
 3E09 CAEF3D    	JZ	RB0		;IF SO GO GET ANOTHER CHARACTER
 3E0C 05        	DCR	B		;IF NOT DECREMENT THE COUNT IN B
 3E0D 3A0C3F    	LDA	COLUMN		;GET THE COLUMN COUNTER
 3E10 320A3F    	STA	CTEMP1		;SAVE IT AT CTEMP1 FOR LATER
 3E13 C3703E    	JMP	RB65		;JUMP OVER
                ;
                ; CHECK FOR RUBOUT (REMOVE & ECHO LAST CHAR.)
                ;
 3E16 FE7F      CHKRUB:	CPI	7FH		;DO WE HAVE A RUBOUT?
 3E18 C2263E    	JNZ	CHKEOL		;IF NOT JUMP OVER
 3E1B 78        	MOV	A,B		;IF SO MOVE B INTO A
 3E1C B7        	ORA	A		;SET THE FLAGS
 3E1D CAEF3D    	JZ	RB0		;IF B WAS ZERO GO GET ANOTHER
 3E20 7E        	MOV	A,M		;GET THE CHAR AT (ODATA)
 3E21 05        	DCR	B		;DECREMENT THE COUNT IN B
 3E22 2B        	DCX	H		;POINT BACK TO FCB
 3E23 C3A93E    	JMP	RB10		;JUMP TO ECHO THE CHAR
                ;
                ; CHECK FOR CONTROL-E (PHYSICAL END-OF-LINE)
                ;
 3E26 FE05      CHKEOL:	CPI	CTRLE		; IS IT END OF LINE?
 3E28 C2373E    	JNZ	CKPTOG		;JUMP OVER IF NOT
 3E2B C5        	PUSH	B		;IF SO SAVE BC
 3E2C E5        	PUSH	H		;AND FCB ADDRESS
 3E2D CDC93D    	CALL	CRLF		;TURN UP A NEW LINE
 3E30 AF        	XRA	A		;ZERO A
 3E31 320B3F    	STA	CTEMP2		;SET IT INTO CTEMP2
 3E34 C3F13D    	JMP	RB1		;AND GO GET MORE
                ;
                ; CHECK FOR CONTROL-P
                ;
 3E37 FE10      CKPTOG:	CPI	CTRLP		;IS IT THE PRINT TOGGLE
 3E39 C2483E    	JNZ	CKBOL		;IF NOT JUMP PAST
 3E3C E5        	PUSH	H		;IF SO SAVE FCB ADDRESS
 3E3D 210D3F    	LXI	H,LSTCPY	;GET THE POINTER TO PRINT TOGGLE BYTE
 3E40 3E01      	MVI	A,01H		;PUT A 1 INTO A
 3E42 96        	SUB	M		;SUBTRACT IT FROM THE TOGGLE
 3E43 77        	MOV	M,A		;AND PUT IT BACK
 3E44 E1        	POP	H		;RECOVER FCB
 3E45 C3EF3D    	JMP	RB0		;AND GO GET MORE
                ;
                ; CHECK FOR CONTROL-X (BAC+SPACE TO BEG. CURRENT LINE)
                ;
 3E48 FE18      CKBOL:	CPI	CTRLX		;DO WE BACK UP?
 3E4A C25F3E    	JNZ	CKREML		;IF NOT ON TO THE NEXT CHOICE
 3E4D E1        	POP	H		;IF SO RESTORE THE STACK POINTER
 3E4E 3A0B3F    BLOOP:	LDA	CTEMP2		;GET THE BYTE AT CTEMP2
 3E51 210C3F    	LXI	H,COLUMN	;AND POINT TO THE COLUMN COUNTER
 3E54 BE        	CMP	M		;ARE THEY THE SAME?
 3E55 D2E13D    	JNC	REDBUF		;IF SO GO TRY AGAIN FOR INPUT
 3E58 35        	DCR	M		;IF NOT DECREMENT THE CTEMP2 COUNT
 3E59 CDA43D    	CALL	DELAST		;DELETE THE CHARACTER THERE
 3E5C C34E3E    	JMP	BLOOP		;AND LOOP UNTIL WE ARE DONE
                ;
                ; CHECK FOR CONTROL-U
                ;
 3E5F FE15      CKREML:	CPI	CTRLU		;DO WE REMOVE THE LINE AFTER NEWLINE?
 3E61 C26B3E    	JNZ	CKRETL		;IF NOT TRY AGAIN
 3E64 CDB13D    	CALL	LBCRLF		;IF SO PRINT A "#" AND CR
 3E67 E1        	POP	H		;RESTORE THE STACK
 3E68 C3E13D    	JMP	REDBUF		;AND TRY FOR INPUT AGAIN
                ;
                ; CHECK FOR CONTROL-R (RETYPE CURRENT LINE AFTER NEW LINE)
                ;
 3E6B FE12      CKRETL:	CPI	CTRLR		;WANT TO RETYPE?
 3E6D C2A63E    	JNZ	ECHOCC		;IF NOT ONWARD FOR NEXT
 3E70 C5        RB65:	PUSH	B		;IF SO SAVE THE COUNT IN B
 3E71 CDB13D    	CALL	LBCRLF		;PRINT A "#" AND CRLF
 3E74 C1        	POP	B		;RECOVER ODATA
 3E75 E1        	POP	H		;AND FCB
 3E76 E5        	PUSH	H		;SAVING FCB AGAIN
 3E77 C5        	PUSH	B		;AND ODATA
 3E78 78        RB7:	MOV	A,B		;MOVE THE COUNT INTO 
 3E79 B7        	ORA	A		;SEE IF IT IS ZERO
 3E7A CA8A3E    	JZ	FIXCOL		;IF SO JUMP OVER
 3E7D 23        	INX	H		;IF NOT POINT TO ODATA
 3E7E 4E        	MOV	C,M		;PULL THE BYTE THERE INTO C
 3E7F 05        	DCR	B		;DECREMENT THE COUNT
 3E80 C5        	PUSH	B		;SAVE IT ON THE STACK
 3E81 E5        	PUSH	H		;AND THE ODATA POINTER
 3E82 CD7F3D    	CALL	CTLOUT		;PRINT IT OUT EXPANDING CONTROL CHARS
 3E85 E1        	POP	H		;RECOVER THE ODATA POINTER
 3E86 C1        	POP	B		;AND THE COUNT IN B
 3E87 C3783E    	JMP	RB7		;LOOP UNTIL THE LINE IS OUT
                ;
                ;FIX UP THE COLUMN COUNTERS
                ;
 3E8A E5        FIXCOL:	PUSH	H		;SAVE THE POINTER
 3E8B 3A0A3F    	LDA	CTEMP1		;GET CTEMP1
 3E8E B7        	ORA	A		;SET THE FLAGS
 3E8F CAF13D    	JZ	RB1		;IF ZERO GO GET THE NEXT CHARACTER
 3E92 210C3F    	LXI	H,COLUMN	;POINT TO THE COLUMN COUNTER
 3E95 96        	SUB	M		;SUBTRACT IT FROM THE VALUE OF CTEMP1
 3E96 320A3F    	STA	CTEMP1		;AND SAVE THIS BACK IN CTEMP1
 3E99 CDA43D    FXLOOP:	CALL	DELAST		;DELETE THE LAST CHARACTER
 3E9C 210A3F    	LXI	H,CTEMP1	;POINT TO CTEMP1
 3E9F 35        	DCR	M		;DECREMENT IT BY ONE
 3EA0 C2993E    	JNZ	FXLOOP		;LOOP TO DELETE ALL OF THEM
 3EA3 C3F13D    	JMP	RB1		;GO GET THE NEXT CHARACTER
                ;
                ;ECHO THE CONTROL CHARACTER
                ;
 3EA6 23        ECHOCC:	INX	H		;MUST BE SOME OTHER CONTROL CHARACTER
 3EA7 77        	MOV	M,A		;PUT THE CHARACTER INTO ODATA+1
 3EA8 04        	INR	B		;BUMP THE COUNT BY ONE
 3EA9 C5        RB10:	PUSH	B		;SAVE IT ON THE STACK
 3EAA E5        	PUSH	H		;AND THE POINTER AS WELL
 3EAB 4F        	MOV	C,A		;PUT THE CHARACTER INTO C
 3EAC CD7F3D    	CALL	CTLOUT		;PRINT IT OUT WITH GRAFIC CONTROL CHARS
 3EAF E1        	POP	H		;RECOVER THE POINTER
 3EB0 C1        	POP	B		;AND THE COUNT
 3EB1 7E        	MOV	A,M		;PUT THE BYTE AT (HL) INTO A
 3EB2 FE03      	CPI	CTRLC		;IS IT AN ABORT?
 3EB4 78        	MOV	A,B		;PUT THE COUNT INTO A
 3EB5 C2BD3E    	JNZ	RB11		;IF NO ABORT JUMP OVER
 3EB8 FE01      	CPI	01H		;IS THE COUNT 1?
 3EBA CA0000    	JZ	BOOTV		;IF SO BOOT
 3EBD B9        RB11:	CMP	C		;IF NOT DOES IT EQUAL C
 3EBE DAEF3D    	JC	RB0		;IF LESS GO GET ANOTHER CHAR
 3EC1 E1        RBEXIT:	POP	H		;RECOVER THE POINTER
 3EC2 70        	MOV	M,B		;PUT THE COUNT IN B THERE
 3EC3 0E0D      	MVI	C,CR		;GET A CR
 3EC5 C3483D    	JMP	CONOUT		;AND PRINT IT OUT
                ;
                ;******************************************************************************
                ;BDOS FUNCTION 1: READ CONSOLE - RETURN WITH BYTE IN A
                ;
 3EC8 CD063D    REDCON:	CALL	CIECHO		;GET A CHAR ECHO IF PRINTABLE
 3ECB C3013F    	JMP	GOBAK		;AND GO BACK WITH IT
                ;
                ;******************************************************************************
                ; BDOS FUNCTION 3: READ READER - RETURN WITH BYTE IN A
                ;
 3ECE CD154A    REDRDR:	CALL	READF		;GET BYTE FROM READER
 3ED1 C3013F    	JMP	GOBAK		;AND RETURN WITH IT
                ;
                ;******************************************************************************
                ; BDOS FUNCTION 6: DIRECT I/O 
                ;	ON ENTRY, C=FF FOR INPUT, C=CHAR FOR OUTPUT
                ;	(BOOK SAYS E REG VICE C)
                ;	 APPEARS CAN ENTER WITH FE OR FF --- ????
                ;
                ;	RETURN WITH CHAR OR STATUS IN A
                ;
 3ED4 79        DIRTIO:	MOV	A,C		;GET REQUEST
 3ED5 3C        	INR	A		;TEST FOR FF=INPUT REQUEST
 3ED6 CAE03E    	JZ	INREQ		;SKIP DOWN IF INPUT REQUEST
 3ED9 3C        	INR	A		;IF FF ADDING ONE WILL SET ZERO FLAG
 3EDA CA064A    	JZ	CONSF		;IF IT WAS GO GET CONSOLE STATUS
 3EDD C30C4A    	JMP	CONOF		;OTHERWISE GO SEND IT OUT
                ;
 3EE0 CD064A    INREQ:	CALL	CONSF		;GET CONSOLE STATUS
 3EE3 B7        	ORA	A		;SET FLAGS
 3EE4 CA9149    	JZ	REXIT		;RETURN IF NONE - RESTORE FIRST
 3EE7 CD094A    	CALL	CONIF		;IF SOMEONE IS THERE GO GET IT
 3EEA C3013F    	JMP	GOBAK		;AND RETURN WITH IT
                ;
                ;******************************************************************************
                ; BDOS FUNCTION 7: GET IO BYTE INTO A
                ;
 3EED 3A0300    GETIOB:	LDA	IOBYTE		;GET THE IOBYTE
 3EF0 C3013F    	JMP	GOBAK		;AND GO BACK WITH IT
                ;
                ;******************************************************************************
                ; BDOS FUNCTION 8: SET IO BYTE FROM C INTO PLACE
                ;
 3EF3 210300    PUTIOB:	LXI	H,IOBYTE	;POINT TO THE IOBYTE
 3EF6 71        	MOV	M,C		;PUT THE NEW VALUE IN FROM C
 3EF7 C9        	RET			;AND RETURN
                ;
                ;******************************************************************************
                ; BDOS FUNCTION 9: PRINT CONSOLE BUFFER UNTIL '$'
                ;	ENTRY STRING ADDRESS IN DE
                ;
 3EF8 EB        PRNBUF:	XCHG			;SWAP DE AND HL - HL POINTS TO BUFFER
 3EF9 4D        	MOV	C,L		;AND GET A COPY
 3EFA 44        	MOV	B,H		;  OF HL INTO BC
 3EFB C3D33D    	JMP	PRINT		;GO TO THE PRINT ROUTINE
                ;
                ;******************************************************************************
                ; BDOS FUNCTION 11: CHECK CONSOLE STATUS - RETURN IN A
                ;
 3EFE CD233D    GCSTAT:	CALL	CONBRK		;CHECK FOR ABORT
 3F01 32453F    GOBAK:	STA	ODATA		;SAVE RESULT IN RETURN INFO BYTE
 3F04 C9        JR:	RET			;AND GO BACK TO CALLER
                ;
 3F05 3E01      JR1:	MVI	A,01H		;GET A 1 FOR RETURN
 3F07 C3013F    	JMP	GOBAK		;SET IT IN TO RINFO AND RETURN
                ;
                ;******************************************************************************
                ; CONSOLE INPUT BUFFER DATA STORAGE AREA
                ;
 3F0A 00        CTEMP1:	DB	0		;TEMP USED FOR CONSOLE INPUT BUFFER
 3F0B 00        CTEMP2:	DB	0		;TEMP COUNT HOLDER FOR BUFFER
 3F0C 00        COLUMN:	DB	0		;COLUMN POINTER FOR BUFFER
 3F0D 00        LSTCPY:	DB	0		;LIST COPY TOGGLE BYTE
 3F0E 00        CHRRDY:	DB	0		;CHAR WAITING FLAG
 3F0F 0000      OLDSP:	DB	0,0		;CALLER'S STACK PTR
 3F11 0000000000	DB	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
 3F25 0000000000	DB	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
 3F39 0000000000	DB	0,0,0,0,0,0,0,0	;48 BYTES (ROOM FOR STACK)
 3F41 00        USRCOD:	DB	0		;USER AND DISK CODE LIVES HERE
 3F42 00        CURDSK:	DB	0		;CURRENT DISK HOLDER
 3F43 0000      FCB:	DW	0		;STORAGE FOR CALLER'S PARMS
 3F45 0000      ODATA:	DW	0		;RETURN INFORMATION STORAGE
                ;
                ;******************************************************************************
                ; GOES TO SELECT ERROR
                ;
 3F47 210B3C    PTSERR:	LXI	H,SELERR	;HL=SELECT ERROR SUB ADDR
                ;
                ;******************************************************************************
                ;ROUTINE BRANCHES TO (HL)
                ;
 3F4A 5E        HLGO:	MOV	E,M		;GET (HL) INTO E
 3F4B 23        	INX	H		;BUMP POINTER
 3F4C 56        	MOV	D,M		;AND PULL IN (HL+1) INTO D
 3F4D EB        	XCHG			;SWAP DE AND HL
 3F4E E9        	PCHL			;SWAP PC AND HL AND OFF WE GO
                ;
                ;******************************************************************************
                ; ROUTINE TO MOVE C BYTES DE TO HL
                ;
 3F4F 0C        MOVE:	INR	C		;ADD 1 TO MOVE COUNT TO START LOOP
 3F50 0D        MOVLOP:	DCR	C		;DECREMENT THE LOOP COUNT
 3F51 C8        	RZ			;RETURN IF WE ARE DONE
 3F52 1A        	LDAX	D		;OTHERWISE GET THE BYTE AT (DE)
 3F53 77        	MOV	M,A		;AND PUT IT AT (HL)
 3F54 13        	INX	D		;BUMP THE SOURCE POINTER
 3F55 23        	INX	H		;AND THE DESTINATION POINTER
 3F56 C3503F    	JMP	MOVLOP		;AND LOOP TIL YOU ARE DONE
                ;
                ;******************************************************************************
                ;ROUTINE TO SET UP DISK IDENTIFICATION DATA FOR ACCESS
                ;
 3F59 3A423F    DISKID:	LDA	CURDSK		;GET THE CURRENT LOGGED DISK
 3F5C 4F        	MOV	C,A		;AND PUT IT INTO C
 3F5D CD1B4A    	CALL	SELF		;SELECT DISK - HL COMES BACK WITH DISP PARM
 3F60 7C        	MOV	A,H		;MOVE H INTO A FOR THE ZERO TEST
 3F61 B5        	ORA	L		;OR IN L - ZERO SAYS SELECT ERROR
 3F62 C8        	RZ			;SO RETURN TO LOGDSK WITH ERROR
 3F63 5E        	MOV	E,M		;OTHERWISE MOVE
 3F64 23        	INX	H		;    TRANSLATION ADDRESS
 3F65 56        	MOV	D,M		;       INTO DE
 3F66 23        	INX	H		;BUMP ONCE MORE
 3F67 22B349    	SHLD	SCRT0		;AND SAVE THIS ADDRESS AT SCRATCH 0
 3F6A 23        	INX	H		;MOVE THE POINTER
 3F6B 23          	INX	H		;   TWO DOORS DOWN
 3F6C 22B549    	SHLD	SCRT1		;AND SAVE THIS ADDRESS AT SCRATCH 1
 3F6F 23        	INX	H		;MOVE OVER
 3F70 23        	INX	H		;  TWO MORE
 3F71 22B749    	SHLD	SCRT2		;SAVING THE RESULT AT SCRATCH 2
 3F74 23        	INX	H		;TWO MORE
 3F75 23        	INX	H		;  FOR GOOD MEASURE
 3F76 EB        	XCHG			;SWAP DE AND HL - DE HAS DIRBUF POINTER
 3F77 22D049    	SHLD	TRANS		;SAVE THE ORIGINAL DISP PARM HEADER
 3F7A 21B949    	LXI	H,DTEMP		;POINT TO THE TEMP DMA AREA
 3F7D 0E08      	MVI	C,8		;BYTES TO MOVE
 3F7F CD4F3F    	CALL	MOVE		;MOVE C BYTES DIRBUF TO DTEMP (DONT KNOW WHY)
 3F82 2ABB49    	LHLD	DPB		;GET THE DISK PARM BLOCK ADDRESS
 3F85 EB        	XCHG			;AND PUT IT INTO DE
 3F86 21C149    	LXI	H,DPBLK		;NOW SET HL TO POINT TO STORAGE AREA
 3F89 0E0F      	MVI	C,15		;BYTES TO MOVE
 3F8B CD4F3F    	CALL	MOVE		;MOVE DISK DATA INTO STORAGE AREA
 3F8E 2AC649    	LHLD	DSIZE		;GET THE SIZE OF THIS DISK
 3F91 7C        	MOV	A,H		;HIGH BYTE ZERO SAYS 1024 BYTE BLOCKS
 3F92 21DD49    	LXI	H,BSIZE		;POINT TO BLOCK SIZE BYTE
 3F95 36FF      	MVI	M,0FFH		;PUT IN AN FF
 3F97 B7        	ORA	A		;SET FLAGS
 3F98 CA9D3F    	JZ	JRFF		;RETURN FF IF BLOCKS ARE 1024 BYTES
 3F9B 3600      	MVI	M,0		;OTHERWISE SET IN A ZERO
 3F9D 3EFF      JRFF:	MVI	A,0FFH		;AND GET AN FF INTO A
 3F9F B7        	ORA	A		;SET FLAGS
 3FA0 C9        	RET			;AND RETURN
                ;
                ;******************************************************************************
                ;ROUTINE TO HOME THE SELECTED DISK AND RESET DATA WORDS
                ;
 3FA1 CD184A    HOMDSK:	CALL	HOMF		;HOME THE SELECTED DRIVE
 3FA4 AF        	XRA	A		;GET A ZERO
 3FA5 2AB549    	LHLD	SCRT1		;POINT TO THE CURRENT TRACK STORAGE
 3FA8 77        	MOV	M,A		;PUT IN THE ZERO
 3FA9 23        	INX	H		;POINT TO THE LOW HALF
 3FAA 77        	MOV	M,A		;AND ZERO THIS AS WELL
 3FAB 2AB749    	LHLD	SCRT2		;POINT TO STARTING SECTOR COUNT FOR THIS TRACK
 3FAE 77        	MOV	M,A		;ZERO IT
 3FAF 23        	INX	H		;BUMP POINTER
 3FB0 77        	MOV	M,A		;BOTH HALVES OF THIS WORD
 3FB1 C9        	RET			;AND RETURN
                ;
                ;******************************************************************************
                ;ROUTINE READS INDICATED SECTOR AND CHECKS STATUS
                ;
 3FB2 CD274A    RDSEC:	CALL	DRDF		;READ SECTOR
 3FB5 C3BB3F    	JMP	PERCHK		;JUMP TO CHECK ERROR AND RETURN
                ;
                ;******************************************************************************
                ;ROUTINE TO WRITE INDICATED SECTOR AND CHECK RESULT
                ;
 3FB8 CD2A4A    WRSEC:	CALL	DWRF		;WRITE SECTOR
                ;
 3FBB B7        PERCHK:	ORA	A		;SET FLAGS
 3FBC C8        	RZ			;RETURN IF ALL IS WELL
 3FBD 21093C    	LXI	H,PERERR	;HL=PERMANENT ERR SUB ADDR
 3FC0 C34A3F    	JMP	HLGO		;GO TO ROUTINE
                ;
                ;******************************************************************************
                ;ROUTINE TO GET THE NEXT DIRECTORY SECTOR LOCATION FOR READING
                ;
 3FC3 2AEA49    GETDS:	LHLD	COUNT		;GET THE DIRECTORY COUNT
 3FC6 0E02      	MVI	C,02H		;READY TO SLIDE IT OVER 2 BITS RIGHT
 3FC8 CDEA40    	CALL	SPINHL		;SPIN HL INTO POSITION - SECTOR NUMBER
 3FCB 22E549    	SHLD	GROUP		;SAVE A COPY AT GROUP
 3FCE 22EC49    	SHLD	LDIRPNT		;AND ANOTHER AT DIRECTORY POINTER
 3FD1 21E549    GETD1:	LXI	H,GROUP		;POINT TO DIRECTORY SECTOR NUMBER
 3FD4 4E        	MOV	C,M		;PULL IT
 3FD5 23        	INX	H		;  INTO
 3FD6 46        	MOV	B,M		;    BC
 3FD7 2AB749    	LHLD	SCRT2		;PULL CURRENT SECTOR ADDRESS
 3FDA 5E        	MOV	E,M		;PULL (SCRATCH2) 16 BITS WIDE
 3FDB 23        	INX	H		;  INTO
 3FDC 56        	MOV	D,M		;    DE
 3FDD 2AB549    	LHLD	SCRT1		;PULL CURRENT TRACK ADDRESS
 3FE0 7E        	MOV	A,M		;PULL (SCRATCH1) INTO A
 3FE1 23        	INX	H		;  INTO
 3FE2 66        	MOV	H,M		;    HL
 3FE3 6F        	MOV	L,A		;      16 BITS AT (SCRATCH1) INTO HL
                ;
                ;NEXT TWO BLOCKS SET THE TRACK AND STARTING SECTOR NUMBER FOR THE TRACK
                ;  SO THE DIRECTORY DISK ACCESS WILL BE RIGHT
                ;
 3FE4 79        GETD2:	MOV	A,C		;SUBTRACT
 3FE5 93        	SUB	E		;  TRACK START SECTOR
 3FE6 78        	MOV	A,B		;   FROM
 3FE7 9A        	SBB	D		;     DESIRED SECTOR NUMBER
 3FE8 D2FA3F    	JNC	GETD3		;IF TOO FAR JUMP
 3FEB E5        	PUSH	H		;SAVE CURRENT TRACK ON STACK
 3FEC 2AC149    	LHLD	DPBLK		;GET SECTORS PER TRACK OUT
 3FEF 7B        	MOV	A,E		;SUBTRACT
 3FF0 95        	SUB	L		;  VALUE
 3FF1 5F        	MOV	E,A		;    FROM
 3FF2 7A        	MOV	A,D		;      TRACK START SECTOR
 3FF3 9C        	SBB	H		;        AND LEAVE
 3FF4 57        	MOV	D,A		;           RESULT IN DE
 3FF5 E1        	POP	H		;RESTORE TRACK COUNT
 3FF6 2B        	DCX	H		;DECREMENT COUNT
 3FF7 C3E43F    	JMP	GETD2		;AND LOOP UNTIL START IS LESS THAN DESIRED
                ;
                ; BC HAS THE SECTOR WE WANT, DE THE TRACK START SECTOR NUMBER, HL THE TRACK
                ; 
 3FFA E5        GETD3:	PUSH	H		;SAVE THE TRACK COUNT
 3FFB 2AC149    	LHLD	DPBLK		;GET THE SECTORS PER TRACK
 3FFE 19        	DAD	D		;COMPUTE THE NEXT TRACK START SECTOR NUMBER
 3FFF DA0F40    	JC	GETD4		;IF THIS EXCEEDS THE DESIRED NUMBER JUMP
 4002 79        	MOV	A,C		;OTHERWISE 
 4003 95        	SUB	L		;   SUBTRACT
 4004 78        	MOV	A,B		;      NEW TRACK START NUMBER
 4005 9C        	SBB	H		;        FROM THE DESIRED SECTOR
 4006 DA0F40    	JC	GETD4		;IF OK THEN JUMP OVER
 4009 EB        	XCHG			;OTHERWISE SWAP DE AND HL
 400A E1        	POP	H		;RECOVER TRACK NUMBER
 400B 23        	INX	H		;BUMP IT BY 1
 400C C3FA3F    	JMP	GETD3		;AND LOOP UNTIL DONE
                ;
                ;POINT THE DISK TO THE RIGHT SPOT FOR ACCESS NOW THAT THE COMPUTING IS DONE
                ;
 400F E1        GETD4:	POP	H		;RECOVER TRACK NUMBER
 4010 C5        	PUSH	B		;SAVE DESIRED SECTOR NUMBER
 4011 D5        	PUSH	D		;AND THE TRACK STARTING SECTOR NUMBER
 4012 E5        	PUSH	H		;AND THE TRACK NUMBER AGAIN
 4013 EB        	XCHG			;SWAP DE AND HL
 4014 2ACE49    	LHLD	TOFS		;GET TRACK OFFSET INTO HL
 4017 19        	DAD	D		;ADD IN THE DESIRED TRACK NUMBER
 4018 44        	MOV	B,H		;AND MOVE IT
 4019 4D        	MOV	C,L		;   INTO BC
 401A CD1E4A    	CALL	TRKF		;SELECT TRACK
 401D D1        	POP	D		;RECOVER ENTRY TRACK INTO DE
 401E 2AB549    	LHLD	SCRT1		;GET POINTER TO CURRENT TRACK STORAGE 
 4021 73        	MOV	M,E		;AND PUT
 4022 23        	INX	H		;  THE NEW TRACK
 4023 72        	MOV	M,D		;    BACK INTO SCRATCH
 4024 D1        	POP	D		;RECOVER CURRENT SECTOR NUMBER
 4025 2AB749    	LHLD	SCRT2		;GET STORAGE ADDRESS
 4028 73        	MOV	M,E		;AND SAVE
 4029 23        	INX	H		;  THE NEW CURRENT SECTOR NUMBER
 402A 72        	MOV	M,D		;   THERE
 402B C1        	POP	B		;RECOVER NEW TRACK SECTOR START NUMBER 
 402C 79        	MOV	A,C		;SUBTRACT
 402D 93        	SUB	E		;  TRACK SECTOR START NUMBER
 402E 4F        	MOV	C,A		;    FROM
 402F 78        	MOV	A,B		;      THE DESIRED NUMBER
 4030 9A        	SBB	D		;        AND
 4031 47        	MOV	B,A		;          LEAVE RESULT IN BC
 4032 2AD049    	LHLD	TRANS		;POINT TO TRANSLATION ROUTINE
 4035 EB        	XCHG			;PUT ADDRESS INTO DE
 4036 CD304A    	CALL	SECTRN		;GO DO THE TRANSLATION
 4039 4D        	MOV	C,L		;PUT THE RESULT
 403A 44        	MOV	B,H		;   INTO BC
 403B C3214A    	JMP	SECF		;FINISH SETTING UP THE DISK POINTERS 
                ;
                ;******************************************************************************
                ;ROUTINE GETS EXTENT SECTOR COUNT FROM STORAGE AND FIGURES BLOCK NUMBER
                ;
 403E 21C349    COMBLK:	LXI	H,BLSHFT	;POINT TO BLOCK SHIFT FACTOR
 4041 4E        	MOV	C,M		;PULL IT INTO C
 4042 3AE349    	LDA	ESCNT2		; PULL IN THE EXTENT LOW BYTE
 4045 B7        COMBL1:	ORA	A		;SET FLAGS - CLEAR CARRY
 4046 1F        	RAR			;ROTATE RIGHT THROUGH CARRY
 4047 0D        	DCR	C		;DECREMENT COUNT
 4048 C24540    	JNZ	COMBL1		;LOOP UNTIL DONE
 404B 47        	MOV	B,A		;THEN SAVE THE BYTE INTO B
 404C 3E08      	MVI	A,08H		;GET BIT 3 SET
 404E 96        	SUB	M		;SUBTRACT BLOCK SHIFT FROM THIS VALUE 
 404F 4F        	MOV	C,A		;AND SAVE IT INTO C
 4050 3AE249    	LDA	ESCNT1		;GET THE EXTENT HIGH BYTE
 4053 0D        COMBL2:	DCR	C		;DECREMENT COUNT AGAIN
 4054 CA5C40    	JZ	COMBL3		;IF DONE JUMP
 4057 B7        	ORA	A		;OTHERWISE SET FLAGS - CLEAR CARRY
 4058 17        	RAL			;ROTATE LEFT THROUGH CARRY
 4059 C35340    	JMP	COMBL2		;LOOP UNTIL DONE
                ;
 405C 80        COMBL3:	ADD	B		;ADD IN THE OFFSET 
 405D C9        	RET			;AND RETURN
                ;
                ;******************************************************************************
                ;ROUTINE POINTS INTO THE FCB BLOCK AND RETURNS WITH GROUP POINTER. 
                ;IF BSIZE=0 BLOCKS ARE>1024 AND 16 BITS COME BACK
                ;
 405E 2A433F    GETGRP:	LHLD	FCB		;GET THE FCB ADDRESS
 4061 111000    	LXI	D,16		;AND A 16
 4064 19        	DAD	D		;ADD IN THE OFFSET
 4065 09        	DAD	B		;ADD IN BC AS WELL
 4066 3ADD49    	LDA	BSIZE		;GET THE BLOCK SIZE BYTE
 4069 B7        	ORA	A		;SET FLAGS
 406A CA7140    	JZ	HLPBC		;IF ZERO ADD HL AND BC
 406D 6E        	MOV	L,M		;PULL IN THIS BYTE
 406E 2600      	MVI	H,0		;SET UPPER BYTE 0
 4070 C9        	RET			;RETURN WITH HL SET
                ;
                ; ROUTINE SETS HL = (HL+BC)
                ;
 4071 09        HLPBC:	DAD	B		;ADD HL AND BC
 4072 5E        	MOV	E,M		;MOVE THIS ADDRESS BYTE INTO E
 4073 23        	INX	H		;POINT TO NEXT
 4074 56        	MOV	D,M		;PULL THIS ONE INTO D
 4075 EB        	XCHG			;SWAP DE AND HL
 4076 C9        	RET			;AND GO BACK
                ;
                ;******************************************************************************
                ;ROUTINE TAKES SECTOR COUNT FOR DIRECTORY AREA AND GETS THE GROUP POINTER OUT
                ;
 4077 CD3E40    SECGRP:	CALL	COMBLK		;GET THE BLOCK NUMBER
 407A 4F        	MOV	C,A		;AND PUT IT INTO C
 407B 0600      	MVI	B,0		;ZERO OUT B
 407D CD5E40    	CALL	GETGRP		;NOW GO GET THE RIGHT GROUP
 4080 22E549    	SHLD	GROUP		;SAVE IT AT GROUP STORAGE
 4083 C9        	RET			;AND GO BACK
                ;
                ;******************************************************************************
                ; ROUTINE CHECKS GROUP AND SETS FLAGS IF ZERO - NO GROUP 0 SHOULD BE THERE
                ;
 4084 2AE549    TSTGRP:	LHLD	GROUP		;GET THE GROUP POINTER OUT
 4087 7D        	MOV	A,L		;MOVE LOW INTO A
 4088 B4        	ORA	H		;OR WITH H TO SET FLAGS
 4089 C9        	RET			;AND GO BACK
                ;
                ;******************************************************************************
                ; ROUTINE APPEARS TO FIGURE ACTUAL SECTOR NUMBER FROM GROUP POINTER
                ;
 408A 3AC349    COMSEC:	LDA	BLSHFT		;GET THE BLOCK SHIFT FACTOR
 408D 2AE549    	LHLD	GROUP		;AND THE GROUP POINTER INTO HL
 4090 29        COMS1:	DAD	H		;SLIDE IT RIGHT
 4091 3D        	DCR	A		;AND DECREMENT COUNT
 4092 C29040    	JNZ	COMS1 		;LOOPING UNTIL IT HAS SHIFTED RIGHT AMOUNT
 4095 22E749    	SHLD	DIRPNT		;THEN SAVE IT IN THE DIRECTORY POINTER
 4098 3AC449    	LDA	BLKMSK		;NOW GET THE BLOCK MASK OUT
 409B 4F        	MOV	C,A		;SAVE IT IN C
 409C 3AE349    	LDA	ESCNT2		;GET THE LOW EXTENT COUNTER
 409F A1        	ANA	C		;AND IT WITH THE BLOCK MASK
 40A0 B5        	ORA	L		;OR IN THE DIRECTORY POINTER LOW BYTE
 40A1 6F        	MOV	L,A		;SLIDE THIS BACK INTO L
 40A2 22E549    	SHLD	GROUP		;AND SAVE THIS ADDRESS AT GROUP
 40A5 C9        	RET			;THEN BACK TO SENDER
                ;
                ;******************************************************************************
                ;ROUTINE TO POINT TO INFORMATION + 12 - THE EXTENT BYTE OF THE FCB
                ;
 40A6 2A433F    GETEX:	LHLD	FCB		;GET THE FCB POINTER
 40A9 110C00    	LXI	D,12		;AND GET A 12
 40AC 19        	DAD	D		;ADD IN THE OFFSET
 40AD C9        	RET			;RETURN WITH HL SET TO EXTENT ADDRESS
                ;
                ;******************************************************************************
                ;ROUTINE SETS HL TO CURRENT RECORD (CR) AND DE TO RECORD COUNT (RC)
                ;
 40AE 2A433F    SETPT:	LHLD	FCB		;GET THE FCB ADDRESS
 40B1 110F00    	LXI	D,15		;GET AN OFFSET OF 15
 40B4 19        	DAD	D		;HL NOW POINTS TO RC ADDRESS
 40B5 EB        	XCHG			;SWAP NEW VALUE INTO DE
 40B6 211100    	LXI	H,17		;NOW GET AN OFFSET OF 17
 40B9 19        	DAD	D		;ADD THIS IN SO HL POINTS TO CR
 40BA C9        	RET			;RETURN WITH HL AND DE SET
                ;
                ;******************************************************************************
                ;ROUTINE APPEARS TO GET THE EXTENT BYTE FROM FCB AND SET UP EXTENT POINTERS
                ;
 40BB CDAE40    FIXEXT:	CALL	SETPT		;SET RECORD POINTERS
 40BE 7E        	MOV	A,M		;GET THE CURRENT RECORD FOR SEQUENTIAL I/O
 40BF 32E349    	STA	ESCNT2		;AND SAVE IT
 40C2 EB        	XCHG			;SWAP DE AND HL
 40C3 7E        	MOV	A,M		;PULL IN THE RECORD COUNT FOR THIS EXTENT
 40C4 32E149    	STA	RECCNT		;AND SAVE IT
 40C7 CDA640    	CALL	GETEX 		;POINT TO EXTENT BYTE IN FCB
 40CA 3AC549    	LDA	EXTMSK		;GET THE EXTENT MASK
 40CD A6        	ANA	M		;AND THE EXTENT BYTE EXTENT MASK
 40CE 32E249    	STA	ESCNT1		;SAVING THE RESULT
 40D1 C9        	RET			;AND RETURN
                ;
                ;******************************************************************************
                ;ROUTINE APPEARS TO SET UP RECORD COUNTERS
                ;
 40D2 CDAE40    FIXREC:	CALL	SETPT		;SET THE RECORD POINTERS
 40D5 3AD549    	LDA	DCODE		;GET THE BYTE
 40D8 FE02      	CPI	02H		;IS IT A 2?
 40DA C2DE40    	JNZ	FIXRC1		;IF NOT JUMP PAST
 40DD AF        	XRA	A		;ZERO OUT A
 40DE 4F        FIXRC1:	MOV	C,A		;MOVE A INTO C
 40DF 3AE349    	LDA	ESCNT2		;GET THE BYTE
 40E2 81        	ADD	C		;ADD IT TO C
 40E3 77        	MOV	M,A		;PUT THE RESULT AWAY AT CR IN FCB
 40E4 EB        	XCHG			;SWAP DE AND HL 
 40E5 3AE149    	LDA	RECCNT		;GET THE BYTE ( RECORD COUNT)
 40E8 77        	MOV	M,A		;PLACE IT AT RC IN FCB
 40E9 C9        	RET			;AND RETURN
                ;
                ;******************************************************************************
                ; SPIN HL BY C BITS RIGHT
                ;
 40EA 0C        SPINHL:	INR	C		;SET UP FOR THE LOOP DECREMENT OF C
 40EB 0D        SPH1:	DCR	C		;DECREMENT LOOP COUNT
 40EC C8        	RZ			;RETURN IF ALL IS WELL
 40ED 7C        	MOV	A,H		;OTHERWISE GET H INTO A
 40EE B7        	ORA	A		;CLEAR CARRY
 40EF 1F        	RAR			;ROTATE RIGHT THROUGH CARRY
 40F0 67        	MOV	H,A		;PUT THE NEW BYTE BACK
 40F1 7D        	MOV	A,L		;MOVE L INTO A
 40F2 1F        	RAR			;ROTATE IT AS WELL
 40F3 6F        	MOV	L,A		;AND PUT IT BACK
 40F4 C3EB40    	JMP	SPH1		;LOOP UNTIL THE COUNT QUITS
                ;
                ;******************************************************************************
                ;ROUTINE TO COMPUTE A CHECK SUM ACROSS A BUFFER OF 128 BYTES
                ;
 40F7 0E80      SUM128:	MVI	C,128		;WE WILL SUM 128 BYTES IN THE TEMP BUFFER
 40F9 2AB949    	LHLD	DTEMP		;GET THE ADDRESS OF THE BUFFER FROM DTEMP
 40FC AF        	XRA	A		;ZERO A
 40FD 86        SUM1:	ADD	M		;ADD IN THE BYTE AT (HL)
 40FE 23        	INX	H		;BUMP POINTER TO NEXT
 40FF 0D        	DCR	C		;DECREMENT COUNT
 4100 C2FD40    	JNZ	SUM1		;LOOP IF WE ARE NOT FINISHED
 4103 C9        	RET			;OTHERWISE GO BACK WITH SUM IN A
                ;
                ;******************************************************************************
                ;ROUTINE TO SLIDE HL LEFT C BITS 
                ;
 4104 0C        SPINBIT:INR	C		;BUMP FOR THE DECREMENT
 4105 0D        SPB1:	DCR	C		;DECREMENT THE LOOP COUNT
 4106 C8        	RZ			;RETURN WHEN DONE
 4107 29        	DAD	H		;SLIDE HL LEFT ONE BIT
 4108 C30541    	JMP	SPB1		;SPIN UNTIL COUNT ZEROES
                ;
                ;******************************************************************************
                ;SET THE DISK BIT IN THE VECTOR - BC HAS THE CURRENT VECTOR
                ;
 410B C5        SETDBT:	PUSH	B		;SAVE THE BC PAIR
 410C 3A423F    	LDA	CURDSK		;GET THE CURRENT DISK
 410F 4F        	MOV	C,A		;PUT IT INTO C
 4110 210100    	LXI	H,1		;GET A 1 INTO HL
 4113 CD0441    	CALL	SPINBIT		;SPIN HL INTO RIGHT SPOT TO SET RO
 4116 C1        	POP	B		;RECOVER BC
 4117 79        	MOV	A,C		;PUT C INTO A
 4118 B5        	ORA	L		;OR IN THE RO FLAG LOW
 4119 6F        	MOV	L,A		;PUT IT BACK
 411A 78        	MOV	A,B		;PULL IN THE HIGH BYTE
 411B B4        	ORA	H		;OR IN THE RO FLAG HIGH
 411C 67        	MOV	H,A		;PUT IT BACK
 411D C9        	RET			;AND RETURN WITH NEW RO VECTOR IN HL
                ;
                ;******************************************************************************
                ;ROUTINE TO CHECK FOR DRIVE READ-ONLY STATE
                ;
 411E 2AAD49    ISRO:	LHLD	ROVEC		;POINT TO THE RO VECTOR
 4121 3A423F    	LDA	CURDSK		;GET THE CURRENT DISK
 4124 4F        	MOV	C,A		;AND PUT IT INTO C
 4125 CDEA40    	CALL	SPINHL		;SPIN THE RO VECTOR INTO POSITION
 4128 7D        	MOV	A,L		;AND PULL L INTO A
 4129 E601      	ANI	01H		;MASK OFF ALL BUT BIT 0
 412B C9        	RET			;AND RETURN WITH FLAGS ZERO FOR NO,1 FOR YES
                ;
                ;******************************************************************************
                ; BDOS FUNCTION 28: MAKES DRIVE READ ONLY
                ;	
 412C 21AD49    MAKRO:	LXI	H,ROVEC		;POINT TO THE RO VECTOR
 412F 4E        	MOV	C,M		;PULL IN THE LOW HALF
 4130 23        	INX	H		;POINT TO HIGH BYTE
 4131 46        	MOV	B,M		;PULL THIS ONE INTO B - GOT IT ALL
 4132 CD0B41    	CALL	SETDBT		;GO SET THIS DRIVE RO
 4135 22AD49    	SHLD	ROVEC		;AND SAVE THE NEW RO VECTOR BACK FOR LATER
 4138 2AC849    	LHLD	DIRMAX		;GET THE DIRECTORY MAX VALUE
 413B 23        	INX	H		;POINT TO RO + 1
 413C EB        	XCHG			;SWAP THIS ADDRESS INTO DE
 413D 2AB349    	LHLD	SCRT0		;POINT TO SCRATCH0
 4140 73        	MOV	M,E		;PUT RO + 1 
 4141 23        	INX	H		;   INTO
 4142 72        	MOV	M,D		;     SCRATCH0
 4143 C9        	RET			;AND GO BACK
                ;
                ;******************************************************************************
                ;ROUTINE TO CHECK FOR FILE READ ONLY
                ;
 4144 CD5E41    CHKFRO:	CALL	PNTDIR		;SET UP HL TO DMA + OFFSET
 4147 110900    CHKFR1:	LXI	D,9		;GET 9 - POINT TO FILE RO BIT IN T1
 414A 19        	DAD	D		;ADD IT TO THE POINTER
 414B 7E        	MOV	A,M		;PULL IN THIS BYTE
 414C 17        	RAL			;ROTATE IT LEFT THROUGH CARRY
 414D D0        	RNC			;IF BIT 7 WAS NOT SET RETURN
 414E 210F3C    	LXI	H,RONERR	;HL=READ-ONLY ERROR SUB ADDR
 4151 C34A3F    	JMP	HLGO		;GO TO ROUTINE
                ;
                ;******************************************************************************
                ;SEE IF THE SELECTED DRIVE IS READ ONLY - SAY WE CANT WRITE IF SO
                ;
 4154 CD1E41    ROCHK:	CALL	ISRO		;IS THE CURRENT DRIVE READ ONLY?
 4157 C8        	RZ			;RETURN IF NOT - WE CAN WRITE
 4158 210D3C    	LXI	H,ROERR		;OTHERWISE POINT TO ERROR ROUTINE
 415B C34A3F    	JMP	HLGO		;GO TO ROUTINE
                ;
                ;******************************************************************************
                ;ROUTINE TO POINT TO DIRECTORY ENTRY STORED IN BUFFER
                ;
 415E 2AB949    PNTDIR:	LHLD	DTEMP		;GET THE TEMP BUFFER ADDRESS OUT
 4161 3AE949    	LDA	DIROFF		;GET THE OFFSET FROM STORAGE
 4164 85        PNTD1:	ADD	L		;ADD IT TO A
 4165 6F        	MOV	L,A		;  AND PUT IT INTO L
 4166 D0        	RNC			;    IF NO OVERFLOW GO BACK
 4167 24        	INR	H		;OTHERWISE ADD IN THE OVERFLOW
 4168 C9        	RET			;AND THEN RETURN
                ;
                ;******************************************************************************
                ;ROUTINE GETS THE S2 BYTE AT (FCB + 14)
                ;
 4169 2A433F    GETS2:	LHLD	FCB		;GET THE INPUT FCB ADDRESS
 416C 110E00    	LXI	D,14		;POINT 14 DOWNSTREAM
 416F 19        	DAD	D		;SET UP THIS ADDRESS
 4170 7E        	MOV	A,M		;PULL THIS BYTE INTO A
 4171 C9        	RET			;AND GO BACK
                ;
                ;******************************************************************************
                ;ROUTINE SETS THE S2 BYTE AT (FCB + 14) TO ZERO
                ;
 4172 CD6941    ZS2:	CALL	GETS2		;GET THE ADDRESS OF S2
 4175 3600      	MVI	M,0		;AND SET IN A ZERO
 4177 C9        	RET			;AND GO BACK
                ;
                ;******************************************************************************
                ;ROUTINE SETS BIT 8 OF S2
                ;
 4178 CD6941    SETS28:	CALL	GETS2		;POINT TO S2
 417B F680      	ORI	80H		;OR IN THE EIGTH BIT
 417D 77        	MOV	M,A		;AND PUT THIS VALUE BACK
 417E C9        	RET			;AND RETURN
                ;
                ;******************************************************************************
                ;ROUTINE SUBTRACTS COUNTER FROM WORD AT SCRATCH0
                ;
 417F 2AEA49    SUBCS0:	LHLD	COUNT		;GET THE COUNTER
 4182 EB        	XCHG			;SWAP IT INTO DE
 4183 2AB349    	LHLD	SCRT0		;THEN GET SCRATCH0 DATA WORD
 4186 7B        	MOV	A,E		;AND SUBTRACT
 4187 96        	SUB	M		;  DATA AT SCRATCH 0
 4188 23        	INX	H		;    FROM
 4189 7A        	MOV	A,D		;      THE 
 418A 9E        	SBB	M		;        COUNTER
 418B C9        	RET			;AND GO BACK WITH RESULT SET IN FLAGS?
                ;
                ;******************************************************************************
                ;ROUTINE CHECKS COUNT AGAINST SCRATCH0 AND DECREMENTS COUNT IF OK
                ;
 418C CD7F41    CHKINC:	CALL	SUBCS0		;COMPARE COUNTER AND (SCRATCH0)
 418F D8        	RC			;IF (SCRATCH0)>COUNTER RETURN
 4190 13        	INX	D		;OTHERWISE BUMP DE
 4191 72        	MOV	M,D		;AND PLACE IT
 4192 2B        	DCX	H		;  INTO
 4193 73        	MOV	M,E		;    (SCRATCH0)
 4194 C9        	RET			;AND RETURN
                ;
                ;******************************************************************************
                ;ROUTINE TO COMPUTE HL = DE - HL
                ;
 4195 7B        SUBHD:	MOV	A,E		;PULL E INTO A
 4196 95        	SUB	L		;SUBTRACT FROM L
 4197 6F        	MOV	L,A		;AND PUT IT BACK
 4198 7A        	MOV	A,D		;THEN MOVE IN THE D VALUE 
 4199 9C        	SBB	H		;AND SUBTRACT WITH BORROW
 419A 67        	MOV	H,A		;PUT BACK INTO H
 419B C9        	RET			;AND RETURN
                ;
                ;******************************************************************************
                ;ROUTINE TO CHECK DIRECTORY AREA WITH CHECK SUM TO SEE IF IT CHANGED
                ;
 419C 0EFF      CHKSUM:	MVI	C,0FFH		;GET THE DEFAULT RETURN CODE
 419E 2AEC49    CHKCNG:	LHLD	LDIRPNT		;POINT TO THE DIRECTORY AREA
 41A1 EB        	XCHG			;PUT THE ADDRESS INTO DE
 41A2 2ACC49    	LHLD	CKSIZE		;GET THE CHECK SIZE
 41A5 CD9541    	CALL	SUBHD		;COMPUTE HL = DE - HL 
 41A8 D0        	RNC			;RETURN IF THEY WERE THE SAME
 41A9 C5        	PUSH	B		;OTHERWISE SAVE THE BC REGS
 41AA CDF740    	CALL	SUM128		;AND COMPUTE THE NEW CHECK SUM
 41AD 2ABD49    	LHLD	CHANGE		;POINT TO THE CHANGE STORAGE AREA
 41B0 EB        	XCHG			;SWAP DE AND HL
 41B1 2AEC49    	LHLD	LDIRPNT		;POINT TO THE DIRECTORY AREA
 41B4 19        	DAD	D		;ADD IN THE CHANGE WORD
 41B5 C1        	POP	B		;RECOVER BC
 41B6 0C        	INR	C		;BUMP COUNT BY ONE
 41B7 CAC441    	JZ	CHK1		;IF ZERO SAVE A AT (HL) AND RETURN
 41BA BE        	CMP	M		;IF NOT CHECK A AND (HL) 
 41BB C8        	RZ			;RETURN IF THEY ARE THE SAME
 41BC CD7F41    	CALL	SUBCS0		;OTHERWISE CHECK COUNTER AND (SCRATCH0)
 41BF D0        	RNC			;RETURN IF THEY ARE OK
 41C0 CD2C41    	CALL	MAKRO		;MAKE THE DISK READ ONLY IF NOT
 41C3 C9        	RET			;AND RETURN
                ;
 41C4 77        CHK1:	MOV	M,A		;PUT A INTO (HL)
 41C5 C9        	RET			;AND RETURN
                ;
                ;******************************************************************************
                ;ROUTINE TO WRITE DIRECTORY SECTOR OUT
                ;
 41C6 CD9C41    WRTDS:	CALL	CHKSUM		;CHECK THE DIRECTORY CHECK SUM
 41C9 CDE041    	CALL	SETEMP		;IF OK SET DMA ADDRESS UP
 41CC 0E01      	MVI	C,01H		;GET THE CODE INTO C
 41CE CDB83F    	CALL	WRSEC		;WRITE THE SECTOR
 41D1 C3DA41    	JMP	SETDMA		;RESET THE DMA ADDRESS AND RETURN
                ;
                ;******************************************************************************
                ;ROUTINE TO READ THE NEXT SECTOR FROM THE DISK
                ;
 41D4 CDE041    GETNXT:	CALL	SETEMP		;SET THE DMA ADDRESS TO (DTEMP)
 41D7 CDB23F    	CALL	RDSEC		;AND READ THE NEXT SECTOR
                ;
                ;******************************************************************************
                ;TELL BIOS THE CORRECT DMA ADDRESS
                ;
 41DA 21B149    SETDMA:	LXI	H,DMAADR	;POINT TO THE DMA ADDRESS WORD
 41DD C3E341    	JMP	SET2		;AND TELL BIOS ABOUT IT
                ;
                ;******************************************************************************
                ; SET THE DMA ADDRESS TO DTEMP
                ;
 41E0 21B949    SETEMP:	LXI	H,DTEMP		;GET THE DMA ADDRESS FROM DTEMP
                ;
 41E3 4E        SET2:	MOV	C,M		;MOVE THE LOW BYTE INTO C
 41E4 23        	INX	H		;POINT TO THE NEXT
 41E5 46        	MOV	B,M		;AND PULL HIGH INTO B
 41E6 C3244A    	JMP	DMAF		;SET DMA BUFFER ADDR & RETURN
                ;
                ;******************************************************************************
                ;ROUTINE TO MOVE THE DATA STORED AT (DTEMP) TO (DMAADR)
                ;
 41E9 2AB949    MOVSEC:	LHLD	DTEMP		;POINT TO THE  DMA BUFFER
 41EC EB        	XCHG			;PUT IT INTO DE
 41ED 2AB149    	LHLD	DMAADR		;GET THE DMA ADDRESS FOR THE LOAD
 41F0 0E80      	MVI	C,128		;BYTES TO MOVE
 41F2 C34F3F    	JMP	MOVE		;MOVE C BYTES DE TO HL
                ;
                ;******************************************************************************
                ;ROUTINE CHECKS COUNT - RETURNS 1 IF IT IS ZERO
                ;AND THE FIRST BYTE AT COUNT IF IT IS NONZERO
                ;
 41F5 21EA49    CHKCNT:	LXI	H,COUNT		;GET COUNT
 41F8 7E        	MOV	A,M		;CHECK TO
 41F9 23        	INX	H		;   SEE
 41FA BE        	CMP	M		;     IF IT IS ZERO
 41FB C0        	RNZ			; RETURN IF IT IS NOT   
 41FC 3C        	INR	A		;BUMP UP TO 1 IF IT IS
 41FD C9        	RET			;AND THEN RETURN
                ;
                ;******************************************************************************
                ;ROUTINE SETS COUNTER TO -1 FOR STARTING LOOP
                ;
 41FE 21FFFF    SETCNT:	LXI	H,-1		;START OFF WITH A 16 BIT -1
 4201 22EA49    	SHLD	COUNT		;AND SAVE IT AT COUNT
 4204 C9        	RET			;RETURN TO SENDER
                ;
                ;******************************************************************************
                ;ROUTINE MOVES TO NEXT DIRECTORY ENTRY - COUNT SAYS THE LAST ONE LOOKED AT
                ;
 4205 2AC849    NXTDIR:	LHLD	DIRMAX		;GET THE NUMBER OF DIRECTORY ENTRIES
 4208 EB        	XCHG			;SAVE IT IN DE
 4209 2AEA49    	LHLD	COUNT		;NOW GET THE DIRECTORY COUNTER
 420C 23        	INX	H		;ADD ONE TO IT
 420D 22EA49    	SHLD	COUNT		;AND SAVE IT BACK FOR LATER
 4210 CD9541    	CALL	SUBHD		;LOOKING TOO FAR?
 4213 D21942    	JNC	GOTDIR		;IF NO CARRY STILL ENTRIES LEFT
 4216 C3FE41    	JMP	SETCNT		;OTHERWISE RETURN WITH A 16 BIT -1
                ;
                ;******************************************************************************
                ;ROUTINE TO GET THE NEXT DIRECTORY SECTOR OFF OF THE DISK
                ;
 4219 3AEA49    GOTDIR:	LDA	COUNT		;GET THE DIRECTORY COUNT LOW BYTE
 421C E603      	ANI	03H		;STRIP OFF ALL BUT LOW TWO (4 ENTRIES PER SEC)
 421E 0605      	MVI	B,5		;SET TO SPIN LOW 3 OVER 5
 4220 87        SPINAB:	ADD	A		;MOVE OVER 1 BIT
 4221 05        	DCR	B		;DECREMENT COUNT
 4222 C22042    	JNZ	SPINAB		;LOOP UNTIL DONE
 4225 32E949    	STA	DIROFF		;SAVE THIS FOR LATER
 4228 B7        	ORA	A		;SET FLAGS
 4229 C0        	RNZ			;RETURN IF NOT ZERO
 422A C5        	PUSH	B		;OTHERWISE SAVE BC
 422B CDC33F    	CALL	GETDS		;LOOKS LIKE WE SET FOR GETTING THE NEXT DIR
 422E CDD441    	CALL	GETNXT		;AND READ THE NEXT SECTOR
 4231 C1        	POP	B		;RECOVER THE BC PAIR
 4232 C39E41    	JMP	CHKCNG		;SEE IF THE DISK CHANGED AND RETURN
                ;
                ;******************************************************************************
                ;ROUTINE GETS AN ALLOCATION BIT SET INTO POSITION
                ; AND SETS POINTER TO ALLOCATION BYTE FOR MARKING BLOCKS
                ; BC HAS THE GROUP POINTER - EXIT WITH BC -> ALLOCATION BYTE
                ;				       D  -> BIT FOR THIS GROUP
                ;				       A  -> ALLOCATION BYTE SPUN INTO PLACE
                ;
 4235 79        GETBIT:	MOV	A,C		;SAVE ENTRY C INTO A
 4236 E607      	ANI	07H		;STRIP OFF ALL BUT LOW 3
 4238 3C        	INR	A		;ADD ONE TO THE RESULT - BIT NUMBER FOR GROUP
 4239 5F        	MOV	E,A		;AND PUT THIS INTO E
 423A 57        	MOV	D,A		;AND ANOTHER INTO D FOR EXIT
 423B 79        	MOV	A,C		;GET ANOTHER COPY OF C
 423C 0F        	RRC			;SPIN
 423D 0F        	RRC			;  IT
 423E 0F        	RRC			;    RIGHT 3
 423F E61F      	ANI	1FH		;STRIP OFF HIGH 3 LEAVING HIGH 5 IN PLACE
 4241 4F        	MOV	C,A		;PUT THIS INTO C
 4242 78        	MOV	A,B		;NOW GET ENTRY B
 4243 87        	ADD	A		;AND SPIN
 4244 87        	ADD	A		;  IT LEFT
 4245 87        	ADD	A		;    FOUR
 4246 87        	ADD	A		;     BITS
 4247 87        	ADD	A		;
 4248 B1        	ORA	C		;OR IN THE WORD AT C
 4249 4F        	MOV	C,A		;AND PUT IT BACK INTO C
 424A 78        	MOV	A,B		;GET ANOTHER COPY OF B
 424B 0F        	RRC			;SLIDE
 424C 0F        	RRC			;  OVER 3
 424D 0F        	RRC			;    RIGHT
 424E E61F      	ANI	1FH		;STRIP OFF ALL BUT LOW 3
 4250 47        	MOV	B,A		;PLACE THIS INTO B, BC IS SET
 4251 2ABF49    	LHLD	ALLOCA		;NOW GET THE ALLOCATION POINTER
 4254 09        	DAD	B		;ADD IN THE OFFSET
 4255 7E        	MOV	A,M		;AND PULL IN THIS BYTE OF IT
 4256 07        GBLOOP:	RLC			;ROTATE IT LEFT THROUGH CARRY
 4257 1D        	DCR	E		;DECREMENT THE ROTATE COUNT
 4258 C25642    	JNZ	GBLOOP		;LOOP UNTIL THE BIT IS IN PLACE
 425B C9        	RET			;AND THEN RETURN WITH IT
                ;
                ;******************************************************************************
                ;ROUTINE TO SET ALLOCATION BIT - BC HAS THE GROUP POINTER
                ;ENTER WITH E SET WITH CURRENT ALLOCATION BYTE
                ;
 425C D5        SETBIT:	PUSH	D		;SAVE DE
 425D CD3542    	CALL	GETBIT		;GET ALLOCATION BIT INTO POSITION
 4260 E6FE      	ANI	0FEH		;CLEAR BIT ZERO
 4262 C1        	POP	B		;RESTORE BC - C HAS BIT TO SET 
 4263 B1        	ORA	C		;OR IN THE ALLOCATION BIT
 4264 0F        PUTBAK:	RRC			;SPIN RIGHT
 4265 15        	DCR	D		;DECREMENT COUNT
 4266 C26442    	JNZ	PUTBAK		;LOOP TIL IT IS BACK IN PLACE
 4269 77        	MOV	M,A		;AND THEN PUT IT BACK IN
 426A C9        	RET			;AND RETURN
                ;
                ;******************************************************************************
                ;ROUTINE TO UPDATE ALLOCATION MAP FOR CURRENT DIRECTORY
                ;
 426B CD5E41    FIXALL:	CALL	PNTDIR		;SET POINTER TO DMA + OFFSET
 426E 111000    	LXI	D,16		;GET OFFSET OF 16
 4271 19        	DAD	D		;ADD THIS IN - POINT TO GROUP BYTES
 4272 C5        	PUSH	B		;SAVE BC WITH SET BIT IN C
 4273 0E11      	MVI	C,17		;SET UP TO SPIN 16 TIMES
 4275 D1        FIXAL1:	POP	D		;GET DATA OFF STACK
 4276 0D        	DCR	C		;DECREMENT COUNTER
 4277 C8        	RZ			;RETURN IF IT IS ZERO
 4278 D5        	PUSH	D		;OTHERWISE SAVE THE DATA AGAIN
 4279 3ADD49    	LDA	BSIZE		;GET THE BLOCK SIZE
 427C B7        	ORA	A		;SET THE FLAGS
 427D CA8842    	JZ	FIXAL2		;IF ZERO JUMP - BLOCKS ARE > 1024
 4280 C5        	PUSH	B		;OTHERWISE SAVE THE CURRENT COUNT 
 4281 E5        	PUSH	H		;AND THE ADDRESS DATA
 4282 4E        	MOV	C,M		;PULL IN THE WORD AT (HL)
 4283 0600      	MVI	B,0		;ZERO OUT B - BC NOW HAS GROUP POINTER
 4285 C38E42    	JMP	FIXAL3		;AND JUMP OVER
                ;
 4288 0D        FIXAL2:	DCR	C		;THESE GROUPS ARE TWO BYTES WIDE SO DEC AGAIN
 4289 C5        	PUSH	B		;SAVE THE NEW COUNT ON THE STACK
 428A 4E        	MOV	C,M		;PULL IN THE HIGH GROUP BYTE
 428B 23        	INX	H		;  POINT TO LOW
 428C 46        	MOV	B,M		;     AND PULL IT IN SO BC HAS BOTH
 428D E5        	PUSH	H		;SAVE THIS ADDRESS
 428E 79        FIXAL3:	MOV	A,C		;PUT THE NEW DATA INTO A
 428F B0        	ORA	B		;COMPARE WITH B
 4290 CA9D42    	JZ	FIXAL4		;IF IT IS ZERO BLOCK IS NOT ALLOCATED
 4293 2AC649    	LHLD	DSIZE		;GET THE NUMBER OF DISK BLOCKS
 4296 7D        	MOV	A,L		;SUBTRACT
 4297 91        	SUB	C		;   HL
 4298 7C        	MOV	A,H		;     FROM
 4299 98        	SBB	B		;       BC
 429A D45C42    	CNC	SETBIT		;IF NOT TOO BIG, GO SET THE BIT
 429D E1        FIXAL4:	POP	H		;RECOVER THE GROUP POINTER
 429E 23        	INX	H		;BUMP IT BY ONE
 429F C1        	POP	B		;RECOVER COUNT
 42A0 C37542    	JMP	FIXAL1		;AND SPIN UNTIL DONE
                ;
                ;******************************************************************************
                ;ROUTINE TO GET THE ALLOCATION VECTOR
                ;
 42A3 2AC649    GETAL:	LHLD	DSIZE		;GET THE MAX NUMBER OF BLOCKS
 42A6 0E03      	MVI	C,03H		;SET TO 
 42A8 CDEA40    	CALL	SPINHL		;  DIVIDE BY EIGHT 
 42AB 23        	INX	H		;ADD 1 FOR THE MAP SIZE
 42AC 44        	MOV	B,H		;AND PUT MAP SIZE 
 42AD 4D        	MOV	C,L		;  INTO BC - NUMBER OF BYTES IN ALLOCATION MAP
 42AE 2ABF49    	LHLD	ALLOCA		;POINT TO ALLOCATION STORAGE AREA
 42B1 3600      CLRALL:	MVI	M,0		;PUT IN A ZERO
 42B3 23        	INX	H		;BUMP THE POINTER
 42B4 0B        	DCX	B		;ONE LESS GROUP TO ZERO OUT
 42B5 78        	MOV	A,B		;PUT THE NEW COUNT INTO A
 42B6 B1        	ORA	C		;CHECK FOR DONE
 42B7 C2B142    	JNZ	CLRALL		;IF NOT LOOP UNTIL SO
 42BA 2ACA49    	LHLD	AL01		;IF DONE GET DIRECTORY ALLOCATION BITS
 42BD EB        	XCHG			;SWAP DE AND AL01
 42BE 2ABF49    	LHLD	ALLOCA		;POINT TO ALLOCATION STOGARE
 42C1 73        	MOV	M,E		;PUT DIRECTORY ALLOCATION BITS
 42C2 23        	INX	H		;  INTO THAT 
 42C3 72        	MOV	M,D		;     STORAGE AREA CAUSE THEY ARE BUSY
 42C4 CDA13F    	CALL	HOMDSK		;HOME THE SELECTED DISK
 42C7 2AB349    	LHLD	SCRT0		;GET THE SCRATCH 0 ADDRESS
 42CA 3603      	MVI	M,03H		;SAVE A 3 AT (SCRATCH0)
 42CC 23        	INX	H		;POINT TO (SCRATCH0+1)
 42CD 3600      	MVI	M,0		;AND ZERO THIS OUT - IT HAS 16 BIT 3 NOW
 42CF CDFE41    	CALL	SETCNT		;SET A COUNTER TO -1
 42D2 0EFF      GETA1:	MVI	C,0FFH		;SET THE EXIT CODE IN
 42D4 CD0542    	CALL	NXTDIR		;SET THE NEXT DIRECTORY POINTERS
 42D7 CDF541    	CALL	CHKCNT		;WAS THERE ONE?
 42DA C8        	RZ			;RETURN IF NOT
 42DB CD5E41    	CALL	PNTDIR		;POINT TO THE RIGHT SPOT
 42DE 3EE5      	MVI	A,DELDAT	;GET THE FILE DELETED MARK
 42E0 BE        	CMP	M		;IS THIS WHAT WE SEE?
 42E1 CAD242    	JZ	GETA1		;KEEP LOOKING FOR A NONEMPTY BLOCK
 42E4 3A413F    	LDA	USRCOD		;GET THE USER BYTE
 42E7 BE        	CMP	M		;TEST THIS AGAINST THE FIRST BYTE
 42E8 C2F642    	JNZ	GETA2		;IF WE DON'T MATCH MARK THIS BLOCK
 42EB 23        	INX	H		;BUMP POINTER TO FILE NAME ENTRY
 42EC 7E        	MOV	A,M		;PULL THE BYTE IN
 42ED D624      	SUI	'$'		;IS THIS A SUBMIT FILE NAME $$$.SUB 
 42EF C2F642    	JNZ	GETA2		;IF NOT TAKE THIS BLOCK ALSO
 42F2 3D        	DCR	A		;OTHERWISE SET A TO FF
 42F3 32453F    	STA	ODATA		;AND SAVE IT AT ODATA FOR CCP TO USE
 42F6 0E01      GETA2:	MVI	C,01H		;SET THE BIT INTO C
 42F8 CD6B42    	CALL	FIXALL		;FIX THIS ALLOCATION BIT
 42FB CD8C41    	CALL	CHKINC		;TEST FOR TOO FAR - BUMP COUNT IF NOT
 42FE C3D242    	JMP	GETA1		;SPIN UNTIL DONE WITH THE SCAN
                ;
                ;******************************************************************************
                ;ROUTINE LOADS RETURN CODE AND GOES BACK TO SENDER
                ;
 4301 3AD449    RETCOD:	LDA	SCODE1		;
 4304 C3013F    	JMP	GOBAK		;
                ;
                ;******************************************************************************
                ;ROUTINE APPEARS TO CHECK EXTENT BYTE
                ;
 4307 C5        CHKEXT:	PUSH	B		;GET THE ENTRY BC SAFE
 4308 F5        	PUSH	PSW		;AND THE ACCUMULATOR
 4309 3AC549    	LDA	EXTMSK		;GET THE EXTENT MASK
 430C 2F        	CMA			;FLIP IT OVER
 430D 47        	MOV	B,A		;AND SAVE IT INTO B
 430E 79        	MOV	A,C		;MOVE C INTO A
 430F A0        	ANA	B		;AND IT WITH THE FLIPPED EXTENT MASK
 4310 4F        	MOV	C,A		;SAVE THIS INTO C
 4311 F1        	POP	PSW		;GET THE ENTRY A BACK
 4312 A0        	ANA	B		;AND WITH FLIP EXTENT MASK
 4313 91        	SUB	C		;SUBTRACT C
 4314 E61F      	ANI	1FH		;MASK OFF HIGH BIT
 4316 C1        	POP	B		;RECOVER THE ENTRY BC
 4317 C9        	RET			;AND GO BACK CONFUSED
                ;
                ;******************************************************************************
                ;SEARCH FOR A SPECIFIED FILE - SET FLAGS TO SAY HOW IT WENT
                ;USED BY ALL FILE ROUTINES TO SET UP FILE INFORMATION
                ;
 4318 3EFF      SEARCH:	MVI	A,0FFH		;SET RETURN CODE UP
 431A 32D449    	STA	SCODE1		;AND SAVE IT FOR LATER
 431D 21D849    	LXI	H,SCODE		;POINT TO SEARCH CODE AREA
 4320 71        	MOV	M,C		;SAVE ENTRY CODE AWAY
 4321 2A433F    	LHLD	FCB		;GET THE ENTRY FCB ADDRESS
 4324 22D949    	SHLD	SEARA		;SAVE A COPY 
 4327 CDFE41    	CALL	SETCNT		;SET THE SEARCH COUNTER UP
 432A CDA13F    	CALL	HOMDSK		;HOME THE SELECTED DISK
 432D 0E00      SERCHN:	MVI	C,0		;
 432F CD0542    	CALL	NXTDIR		;LOCATE NEXT DIRECTORY ENTRY
 4332 CDF541    	CALL	CHKCNT		;CHECK TO SEE IF ONE WAS FOUND
 4335 CA9443    	JZ	NOTFND		;JUMP OVER IF NOT
 4338 2AD949    	LHLD	SEARA		;GET THE FCB ADDRESS OUT
 433B EB        	XCHG			;INTO DE
 433C 1A        	LDAX	D		;GET THE BYTE AT (DE)
 433D FEE5      	CPI	DELDAT		;IS IT A DELETED FILE? 
 433F CA4A43    	JZ	SERCH1		;IF SO JUMP OVER
 4342 D5        	PUSH	D		;SAVE THIS ADDRESS FOR LATER
 4343 CD7F41    	CALL	SUBCS0		;CHECK COUNT AND INCREMENT
 4346 D1        	POP	D		;RECOVER THE ADDRESS
 4347 D29443    	JNC	NOTFND		;IF NO CARRY WE DIDN'T FIND THE FILE
 434A CD5E41    SERCH1:	CALL	PNTDIR		;POINT TO THE INDICATED DIRECTORY ENTRY
 434D 3AD849    	LDA	SCODE		;GET THE SEARCH CODE OUT
 4350 4F        	MOV	C,A		;STUFF IT INTO C
 4351 0600      	MVI	B,0		;ZERO OUT THE HIGH BYTE
 4353 79        SERCH2:	MOV	A,C		;MOVE IT TO A 
 4354 B7        	ORA	A		;SET THE FLAGS - CHECK FOR ZERO     
 4355 CA8343    	JZ	SEREXT		;IF SO JUMP OVER
 4358 1A        	LDAX	D		;OTHERWISE GET THE FCB FILE NAME CHAR
 4359 FE3F       	CPI	'?'		;IS IT A WILD CARD NAME?
 435B CA7C43    	JZ	MATCH		;IF SO JUMP OVER
 435E 78        	MOV	A,B		;CHECK B
 435F FE0D      	CPI	0DH		;IS IT PAST EXTENT BYTE?
 4361 CA7C43    	JZ	MATCH		;IF SO THIS IS A GOOD FILE TO GO BACK WITH
 4364 FE0C      	CPI	0CH		;HOW ABOUT AT THE EXTENT BYTE?
 4366 1A        	LDAX	D		;GET THE BYTE AGAIN
 4367 CA7343    	JZ	SERCH3		;IF SO JUMP OVER
 436A 96        	SUB	M		;OTHERWISE SUBTRACT THE TWO BYTES
 436B E67F      	ANI	7FH		;STRIP OFF THE SPECIAL BITS
 436D C22D43    	JNZ	SERCHN		;IF NOT ZERO THIS DOESNT MATCH SO TRY AGAIN
 4370 C37C43    	JMP	MATCH		;IF IT MATCHES PRESS ON
                ;
 4373 C5        SERCH3:	PUSH	B		;SAVE BC FROM HARM
 4374 4E        	MOV	C,M		;PULL THE BYTE INTO C
 4375 CD0743    	CALL	CHKEXT		;CHECK THE EXTENT BYTE
 4378 C1        	POP	B		;RECOVER BC
 4379 C22D43    	JNZ	SERCHN		;IF NOT ZERO SEARCH AGAIN
 437C 13        MATCH:	INX	D		;OTHERWISE BUMP FCB POINTER
 437D 23        	INX	H		;AND POINTER INTO MEMORY
 437E 04        	INR	B		;INCREMENT THE FCB COUNT
 437F 0D        	DCR	C		;DECREMENT THE C COUNTER
 4380 C35343    	JMP	SERCH2		;AND KEEP GOING WITH THE SEARCH
                ;
 4383 3AEA49    SEREXT:	LDA	COUNT		;GET THE COUNT
 4386 E603      	ANI	03H		;STRIP OFF THE HIGH 5 BITS
 4388 32453F    	STA	ODATA		;SAVE THIS AT ODATA FOR RETURN
 438B 21D449    	LXI	H,SCODE1	;GET THE RETURN CODE ADDRESS
 438E 7E        	MOV	A,M		;PULL IT INTO A
 438F 17        	RAL			;SLIDE IT LEFT ONE BIT THROUGH CARRY
 4390 D0        	RNC			;IF BIT 7 NOT SET RETURN
 4391 AF        	XRA	A		;OTHERWISE ZERO OUT A
 4392 77        	MOV	M,A		;PUT IT BACK AT SCODE1
 4393 C9        	RET			;THEN GO BACK
                ;
 4394 CDFE41    NOTFND:	CALL	SETCNT		;SET THE COUNTER FOR ERROR CODE
 4397 3EFF      	MVI	A,0FFH		;AND SET THE RETURN BYTE INTO A
 4399 C3013F    	JMP	GOBAK		;THEN RETURN TO SENDER
                ;
                ;******************************************************************************
                ;ROUTINE TO DELETE SPECIFIED FILE
                ;
 439C CD5441    DELETF:	CALL	ROCHK		;SEE IF THE SELECTED DRIVE IS READ ONLY
 439F 0E0C      	MVI	C,0CH		;LOOK FOR NAME AND EXTENT
 43A1 CD1843    	CALL	SEARCH		;GO FIND THE FILE
 43A4 CDF541    DELOOP:	CALL	CHKCNT		;WAS IT THERE
 43A7 C8        	RZ			;RETURN IF NOT - ALL EXTENTS ARE MARKED
 43A8 CD4441    	CALL	CHKFRO		;SEE IF FILE WAS READ ONLY
 43AB CD5E41    	CALL	PNTDIR		;POINT TO DIRECTORY ENTRY
 43AE 36E5      	MVI	M,DELDAT	;PUT IN THE FILE DELETED MARKER
 43B0 0E00      	MVI	C,0		;SET C FOR THE FIX BIT ROUTINE
 43B2 CD6B42    	CALL	FIXALL		;FIX THE ALLOCATION VECTOR
 43B5 CDC641    	CALL	WRTDS		;WRITE OUT THE DIRECTORY SECTOR
 43B8 CD2D43    	CALL	SERCHN		;SEARCH FOR THE NEXT EXTENT
 43BB C3A443    	JMP	DELOOP		;AND LOOP UNTIL DONE
                ;
                ;******************************************************************************
                ;ROUTINE TO CHECK FOR BLOCK AVAILABILITY
                ;
 43BE 50        BLKAVL:	MOV	D,B		;MOVE BC
 43BF 59        	MOV	E,C		;  INTO DE
 43C0 79        BLKA1:	MOV	A,C		;SAVE A COPY OF C INTO A
 43C1 B0        	ORA	B		;  CHECK IF BC IS ZERO
 43C2 CAD143    	JZ	BLKA2		;IF SO JUMP OVER AND LOOK AGAIN
 43C5 0B        	DCX	B		;DECREMENT THE COUNTER
 43C6 D5        	PUSH	D		;SAVE ON THE STACK
 43C7 C5        	PUSH	B		;SAVE BC AS WELL
 43C8 CD3542    	CALL	GETBIT		;CHECK THE ALLOCATION BIT
 43CB 1F        	RAR			;SLIDE IT RIGHT THROUGH CARRY
 43CC D2EC43    	JNC	TAKBLK		;IF NO CARRY IT IS FREE
 43CF C1        	POP	B		;RESTORE
 43D0 D1        	POP	D		;  STACK
 43D1 2AC649    BLKA2:	LHLD	DSIZE		;GET THE DISK SIZE BLOCK COUNT
 43D4 7B        	MOV	A,E		;SUBTRACT
 43D5 95        	SUB	L		;   HL
 43D6 7A        	MOV	A,D		;    FROM
 43D7 9C        	SBB	H		;        DE
 43D8 D2F443    	JNC	BLKA3		;IF NO CARRY ALL IS WELL - JUMP OVER
 43DB 13        	INX	D		;OTHERWISE BUMP DE
 43DC C5        	PUSH	B		;SAVE ON STACK
 43DD D5        	PUSH	D		;    FOR NEXT LOOK
 43DE 42        	MOV	B,D		;PUT DE
 43DF 4B        	MOV	C,E		;   INTO BC
 43E0 CD3542    	CALL	GETBIT		;GET THIS ALLOCATION BIT OUT
 43E3 1F        	RAR			;SLIDE RIGHT TO TEST
 43E4 D2EC43    	JNC	TAKBLK		;IF NO CARRY TAKE THE BLOCK
 43E7 D1        	POP	D		;RECOVER THE
 43E8 C1        	POP	B		;  STACK
 43E9 C3C043    	JMP	BLKA1		;AND KEEP LOOKING
                ;
 43EC 17        TAKBLK:	RAL			;RESTORE THE ALLOCATION BIT
 43ED 3C        	INR	A		;ADD ONE TO SET BIT
 43EE CD6442    	CALL	PUTBAK		;WRITE IT BACK INTO THE VECTOR
 43F1 E1        	POP	H		;RECOVER
 43F2 D1        	POP	D		;  THE STACK
 43F3 C9        	RET			;AND RETURN TO THE CALLER
                ;
 43F4 79        BLKA3:	MOV	A,C		;IS BC
 43F5 B0        	ORA	B		;  ZERO?
 43F6 C2C043    	JNZ	BLKA1		;IF NOT JUMP BACK AND CONTINUE
 43F9 210000    	LXI	H,0		;OTHERWISE GET A 16 BIT ZERO
 43FC C9        	RET			;AND RETURN WITH IT
                ;
                ;******************************************************************************
                ;ROUTINE TO MOVE THE DIRECTORY ENTRY
                ;
 43FD 0E00      MOVDIR:	MVI	C,0		;SET C TO ZERO FOR THE MOVE
 43FF 1E20      	MVI	E,32		;GET THE DIRECTORY SIZE
                ;
                ;******************************************************************************
                ;ROUTINE TO SET THE DIRECTORY ONTO THE DISK
                ;
 4401 D5        SETDIR:	PUSH	D		;SAVE THE COUNT ON THE STACK
 4402 0600      	MVI	B,0		;ZERO THE HIGH BYTE
 4404 2A433F    	LHLD	FCB		;GET THE FCB ADDRESS
 4407 09        	DAD	B		;ADD IN THE OFFSET FOR THE MOVE
 4408 EB        	XCHG			;SAVE IT IN DE
 4409 CD5E41    	CALL	PNTDIR		;POINT TO THE DIRECTORY AREA
 440C C1        	POP	B		;RECOVER THE COUNT
 440D CD4F3F    	CALL	MOVE		;MOVE C BYTES DE TO HL
 4410 CDC33F    SETD1:	CALL	GETDS		;GO PULL IN THE REST OF THE DIRECTORY 
 4413 C3C641    	JMP	WRTDS		;AND WRITE THE CURRENT SECTOR OUT
                ;
                ;******************************************************************************
                ;ROUTINE TO RENAME THE SELECTED FILE
                ;
 4416 CD5441    RENAMF:	CALL	ROCHK		;SEE IF THE SELECTED DISK IS READ ONLY
 4419 0E0C      	MVI	C,0CH		;NO- CHECK NAME AND EXTENT
 441B CD1843    	CALL	SEARCH		;BY CALLING THE SEARCH ROUTINE
 441E 2A433F    	LHLD	FCB		;GET THE INFORMATION FCB ADDRESS 
 4421 7E        	MOV	A,M		;AND PULL THE DRIVECODE
 4422 111000    	LXI	D,16		;WE WILL MOVE DOWN 16 BYTES
 4425 19        	DAD	D		;POINT TO THE NEW FILE NAME IN FCB
 4426 77        	MOV	M,A		;PUT IN THE NEW DRIVE CODE
 4427 CDF541    RENF1:	CALL	CHKCNT		;CHECK THE LOOP COUNTER
 442A C8        	RZ			;RETURN IF ALL EXTENTS ARE RENAMED
 442B CD4441    	CALL	CHKFRO		;SEE IF THE FILW IS READ ONLY
 442E 0E10      	MVI	C,10H		;SET TO MOVE 16 BYTES OF THE FILE NAME
 4430 1E0C      	MVI	E,0CH		;GET THE SEARCH CODE READY
 4432 CD0144    	CALL	SETDIR		;SET IN THE FILE NAME
 4435 CD2D43    	CALL	SERCHN		;SEARCH FOR THE NEXT EXTENT
 4438 C32744    	JMP	RENF1		;LOOP UNTIL NO MORE EXTENTS
                ;
                ;******************************************************************************
                ;ROUTINE SETS UP POINTERS TO INDICATED FILE
                ;
 443B 0E0C      SETFN:	MVI	C,0CH		;LOOK AT NAME AND EXTENT
 443D CD1843    	CALL	SEARCH		;SEARCH FOR THE FILE
 4440 CDF541    SETF1:	CALL	CHKCNT		;SEE IF THERE WAS AN ENTRY LEFT
 4443 C8        	RZ			;RETURN WHEN ALL EXTENTS HAVE BEEN FOUND
 4444 0E00      	MVI	C,0		;
 4446 1E0C      	MVI	E,0CH		;
 4448 CD0144    	CALL	SETDIR		;
 444B CD2D43    	CALL	SERCHN		;LOOK FOR THE NEXT EXTENT
 444E C34044    	JMP	SETF1		;AND LOOP TILL ALL FOUND
                ;
                ;******************************************************************************
                ;ROUTINE TO OPEN SELECTED FILE
                ;
 4451 0E0F      OPENF:	MVI	C,0FH		;LOOK AT FCB THROUGH S1 AND S2 BYTES
 4453 CD1843    	CALL	SEARCH		;SEARCH FOR THE FILE
 4456 CDF541    	CALL	CHKCNT		;WAS IT FOUND
 4459 C8        	RZ			;RETURN IF NOT
 445A CDA640    OPEN1:	CALL	GETEX		;GET THE EXTENT BYTE
 445D 7E        	MOV	A,M		;PULL IT INTO A
 445E F5        	PUSH	PSW		;SAVE IT FOR LATER
 445F E5        	PUSH	H		;SAVE THE ADDRESS AS WELL
 4460 CD5E41    	CALL	PNTDIR		;POINT TO THE DIRECTORY AREA
 4463 EB        	XCHG			;AND PUT THE ADDRESS INTO DE
 4464 2A433F    	LHLD	FCB		;GET THE FCB ADDRESS
 4467 0E20      	MVI	C,32		;BYTES TO MOVE
 4469 D5        	PUSH	D		;SAVE THE DIRECTORY ADDRESS
 446A CD4F3F    	CALL	MOVE		;MOVE C BYTES DE TO HL
 446D CD7841    	CALL	SETS28		;SET BIT 7 OF S2
 4470 D1        	POP	D		;RECOVER THE DIRECTORY ADDRESS
 4471 210C00    	LXI	H,12		;SET TO POINT DOWNSTREAM
 4474 19        	DAD	D		;NOW POINTING TO EXTENT BYTE OF DIRECTORY
 4475 4E        	MOV	C,M		;PULL THIS BYTE IN
 4476 210F00    	LXI	H,15		;READY TO MOVE DOWN AGAIN
 4479 19        	DAD	D		;NOW POINT TO 
 447A 46        	MOV	B,M		;PUT THE EXTENT BYTE BACK HERE
 447B E1        	POP	H		;RECOVER THE FCB ADDRESS
 447C F1        	POP	PSW		;AND THE ENTRY EXTENT BYTE
 447D 77        	MOV	M,A		;PUT THE BYTE BACK
 447E 79        	MOV	A,C		;MOVE THE DIRECTORY EXTENT BYTE INTO A
 447F BE        	CMP	M		;ARE THEY THE SAME
 4480 78        	MOV	A,B		;
 4481 CA8B44    	JZ	OPEN2		;IF SO JUMP
 4484 3E00      	MVI	A,0		;OTHERWISE GET A ZERO
 4486 DA8B44    	JC	OPEN2		;IF IT WAS TOO BIG JUMP OVER
 4489 3E80      	MVI	A,80H		;NOW GET BIT 7 SET
 448B 2A433F    OPEN2:	LHLD	FCB		;POINT TO THE FCB AGAIN
 448E 110F00    	LXI	D,15		;READY TO MOVE IT
 4491 19        	DAD	D		;NOW POINT TO RECORD COUNT
 4492 77        	MOV	M,A		;PULL THIS OUT
 4493 C9        	RET			;AND GO BACK WITH IT
                ;
                ;******************************************************************************
                ;ROUTINE TO CHECK IF (HL) IS ZERO - IF SO MOVE (DE) TO (HL)
                ; 
 4494 7E        CHKCPY:	MOV	A,M		;TEST (HL)
 4495 23        	INX	H		;  FOR
 4496 B6        	ORA	M		;    ZERO
 4497 2B        	DCX	H		;POINT BACK
 4498 C0        	RNZ			;RETURN IF NOT ZERO
 4499 1A        	LDAX	D		;OTHERWISE GET (DE)
 449A 77        	MOV	M,A		;PUT IT AT (HL)
 449B 13        	INX	D		;BUMP
 449C 23        	INX	H		;BOTHOF THEM
 449D 1A        	LDAX	D		;GET (DE)
 449E 77        	MOV	M,A		;AND PUT IT AT (DE)
 449F 1B        	DCX	D		;RESTORE BOTH
 44A0 2B        	DCX	H		;  POINTERS
 44A1 C9        	RET			;AND RETURN
                ;
                ;******************************************************************************
                ;ROUTINE TO CLOSE SELECTED FILE
                ;
 44A2 AF        CLOSEF:	XRA	A		;CHEAP ZERO
 44A3 32453F    	STA	ODATA		;PUT IT AT RETURN INFO BYTE
 44A6 32EA49    	STA	COUNT		;AND ZERO OUT THE COUNT
 44A9 32EB49    	STA	COUNT+1		;   WORD
 44AC CD1E41    	CALL	ISRO		;IS THE DISK READ ONLY
 44AF C0        	RNZ			;RETURN IF SO - CAN'T CLOSE IT 
 44B0 CD6941    	CALL	GETS2		;GET THE S2 BYTE FROM THE FCB
 44B3 E680      	ANI	80H		;STRIP OFF THE LOW EIGHT BITS 
 44B5 C0        	RNZ			;RETURN IF NOT ZERO
 44B6 0E0F      	MVI	C,0FH		;OTHERWISE SET TO LOOK THROUGH S2 IN FCB
 44B8 CD1843    	CALL	SEARCH		;SEARCH FOR THE FILE
 44BB CDF541    	CALL	CHKCNT		;WAS IT THERE
 44BE C8        	RZ			;ZERO SAYS DONE
 44BF 011000    	LXI	B,16		;GET THE POINTER FOR GROUP BYTES IN DIR
 44C2 CD5E41    	CALL	PNTDIR		;POINT TO THE DIRECTORY
 44C5 09        	DAD	B		;ADD IN THE OFFSET - POINTING RIGHT
 44C6 EB        	XCHG			;SWAP DE AND HL
 44C7 2A433F    	LHLD	FCB		;POINT TO THE FCB
 44CA 09        	DAD	B		;ADD IN THE OFFSET AGAIN
 44CB 0E10      	MVI	C,10H		;GET SET FOR 16 BYTES TO MOVE
 44CD 3ADD49    CLOSF1:	LDA	BSIZE		;GET THE BLOCK SIZE BYTE OUT
 44D0 B7        	ORA	A		;IS IT ZERO
 44D1 CAE844    	JZ	CLOSF4		;IF SO BLOCKS > 1024 SO JUMP PAST
                ;
                ;SMALL BLOCKS
                ;
 44D4 7E        	MOV	A,M		;PULL THE BYTE OUT
 44D5 B7        	ORA	A		;TEST FOR ZERO
 44D6 1A        	LDAX	D		;GET THE (DE) OUT
 44D7 C2DB44    	JNZ	CLOSF2		;IF NOT ZERO JUMP OVER
 44DA 77        	MOV	M,A		;OTHERWISE PUT A INTO PLACE
 44DB B7        CLOSF2:	ORA	A		;TEST THE BYTE AGAIN
 44DC C2E144    	JNZ	CLOSF3		;IF NOT ZERO JUMP PAST
 44DF 7E        	MOV	A,M		;OTHERWISE PULL IN THE BYTE
 44E0 12        	STAX	D		;STUFF IT BACK AT (DE)
 44E1 BE        CLOSF3:	CMP	M		;ARE THEY THE SAME
 44E2 C21F45    	JNZ	CLOSF7		;IF NOT JUMP
 44E5 C3FD44    	JMP	CLOSF5		;OTHERWISE SKIP OVER 
                ;
                ;BIG BLOCKS
                ;
 44E8 CD9444    CLOSF4:	CALL	CHKCPY		;CHECK AND INCREMENT
 44EB EB        	XCHG			;EXCHANGE AGAIN
 44EC CD9444    	CALL	CHKCPY		;CHECK AGAIN FOR NEXT BYTE
 44EF EB        	XCHG			;EXCHANGE BACK - READY TO CONTINUE
 44F0 1A        	LDAX	D		;GET THE NEW BYTE FROM (DE)
 44F1 BE        	CMP	M		;DOES IT MATCH (HL)
 44F2 C21F45    	JNZ	CLOSF7		;IF NOT OVER WE GO
 44F5 13        	INX	D		;BUMP POINTER
 44F6 23        	INX	H		;   DATA
 44F7 1A        	LDAX	D		;GET NEXT BYTE
 44F8 BE        	CMP	M		;COMPARE IT AS WELL
 44F9 C21F45    	JNZ	CLOSF7		;AGAIN IF NO MATCH JUMP
 44FC 0D        	DCR	C		;DECREMENT THE COUNT
 44FD 13        CLOSF5:	INX	D		;INCREMENT THE
 44FE 23        	INX	H		;  POINTERS
 44FF 0D        	DCR	C		;DECREMENT THE COUNT
 4500 C2CD44    	JNZ	CLOSF1		;IF NOT DONE SPINN AROUND AGAIN
 4503 01ECFF    	LXI	B,-20		;POINT BACK 
 4506 09        	DAD	B		;  20 BYTES
 4507 EB        	XCHG			;SWAP POINTERS
 4508 09        	DAD	B		;AND BACK THIS ONE UP AS WELL
 4509 1A        	LDAX	D		;PULL IN THE BYTE AT (DE)
 450A BE        	CMP	M		;TEST AGAINST (HL)
 450B DA1745    	JC	CLOSF6		;IF (HL)>(DE) JUMP
 450E 77        	MOV	M,A		;IF NOT PUT A INTO (HL)
 450F 010300    	LXI	B,3		;GET A 3
 4512 09        	DAD	B		;POINT DOWN 3
 4513 EB        	XCHG			;SWAP POINTERS AGAIN
 4514 09        	DAD	B		;DOWN THREE ALSO 
 4515 7E        	MOV	A,M		;GET THE BYTE AT (HL)
 4516 12        	STAX	D		;STUFF IT IN AT (DE)
 4517 3EFF      CLOSF6:	MVI	A,0FFH		;GET THE FLAG DATA
 4519 32D249    	STA	RWFLG1		;SET FLAG TO SAY READING
 451C C31044    	JMP	SETD1		;WRITE OUT THE DIRECTORY BLOCK AND RETURN
                ;
 451F 21453F    CLOSF7:	LXI	H,ODATA		;POINT TO OUTPUT DATA BYTE
 4522 35        	DCR	M		;DECREMENT IT 1
 4523 C9        	RET			;AND GO BACK
                ;
                ;******************************************************************************
                ;MAKE A NEW DIRECTORY ENTRY FOR A NEW FILE
                ;
 4524 CD5441    MAKE:	CALL	ROCHK		; IS THE DISK READ ONLY
 4527 2A433F    	LHLD	FCB		;NOPE - SO GET THE FCB ADDRESS
 452A E5        	PUSH	H		;AND SAVE IT ON THE STACK
 452B 21AC49    	LXI	H,TINFO		;POINT TO THE TINFO AREA
 452E 22433F    	SHLD	FCB		;SAVE THIS AS THE FCB ADDRESS
 4531 0E01      	MVI	C,01H		;SET TO LOOK AT ONLY THE ET BYTE IN THE FCB
 4533 CD1843    	CALL	SEARCH		;SEARCH FOR THE NEW FILE NAME 
 4536 CDF541    	CALL	CHKCNT		;WAS IT THERE
 4539 E1        	POP	H		;GET THE OLD FCB BACK
 453A 22433F    	SHLD	FCB		;RESTORE IT RIGHT
 453D C8        	RZ			;RETURN IF IT WAS THERE
 453E EB        	XCHG			;SAVE FCB IN DE
 453F 210F00    	LXI	H,15		;GET OFFSET TO RECORD COUNT
 4542 19        	DAD	D		;AND SET THE POINTER THERE
 4543 0E11      	MVI	C,17		;GET SET TO SPIN THROUGH 16 BYTES
 4545 AF        	XRA	A		;GET A ZERO READY
 4546 77        MAK1:	MOV	M,A		;AND MOVE ZERO
 4547 23        	INX	H		;  INTO
 4548 0D        	DCR	C		;    ALL
 4549 C24645    	JNZ	MAK1		;     THE GROUP BYTES
 454C 210D00    	LXI	H,13		;GET THE OFFSET TO THE S1 BYTE
 454F 19        	DAD	D		;AND POINT TO IT
 4550 77        	MOV	M,A		;ZERO THIS AS WELL
 4551 CD8C41    	CALL	CHKINC		;SEE IF WE HAVE MORE TO DO
 4554 CDFD43    	CALL	MOVDIR		;COPY THE DIRECTORY IN PLACE
 4557 C37841    	JMP	SETS28		;SET BIT 7 OF S2 AND RETURN
                ;
                ;******************************************************************************
                ;ROUTINE SETS UP FOR THE NEXT EXTENT ACCESS FOR EITHER READ OR WRITE
                ;
 455A AF        NEXTEX:	XRA	A		;GET A ZERO
 455B 32D249    	STA	RWFLG1		;SAY WE ARE WRITING
 455E CDA244    	CALL	CLOSEF		;CLOSE THE FILE
 4561 CDF541    	CALL	CHKCNT		;DID IT EXIST
 4564 C8        	RZ			;RETURN IF NOT
 4565 2A433F    	LHLD	FCB		;GET THE FCB ADDRESS
 4568 010C00    	LXI	B,12		;SET TO POINT TO EXTENT BYTE
 456B 09        	DAD	B		;NOW IT DOES
 456C 7E        	MOV	A,M		;PULL THE THING IN
 456D 3C        	INR	A		;BUMP BY ONE
 456E E61F      	ANI	1FH		;STRIP OFF BIT 7
 4570 77        	MOV	M,A		;AND PUT IT BACK
 4571 CA8345    	JZ	NEXTE1		;IF IT WAS ZERO JUMP OVER
 4574 47        	MOV	B,A		;OTHERWISE SAVE IT IN B
 4575 3AC549    	LDA	EXTMSK		;GET THE EXTENT MASK
 4578 A0        	ANA	B		;AND USE IT
 4579 21D249    	LXI	H,RWFLG1	;AND POINT TO THE FLAG
 457C A6        	ANA	M		;AND IN THIS BYTE AS WELL
 457D CA8E45    	JZ	NEXTE2		;IF ZERO JUMP PAST
 4580 C3AC45    	JMP	NEXTE3		;OTHERWISE OFF TO
                ;
 4583 010200    NEXTE1:	LXI	B,2		;READY TO BUMP 2 MORE
 4586 09        	DAD	B		;ADD IT IN
 4587 34        	INR	M		;INCREMENT THIS BYTE
 4588 7E        	MOV	A,M		;THEN PULL IT IN
 4589 E60F      	ANI	0FH		;STRIP OFF THE HIGH 4 BITS
 458B CAB645    	JZ	NEXTE5		;IF ZERO JUMP
 458E 0E0F      NEXTE2:	MVI	C,0FH		;LOOK THROUGH S2 BYTE IN FCB
 4590 CD1843    	CALL	SEARCH		;LOOK FOR THE INDICATED FILE
 4593 CDF541    	CALL	CHKCNT		;SEE IF IT WAS THERE
 4596 C2AC45    	JNZ	NEXTE3		;IF SO OPEN THE NEXT EXTENT
 4599 3AD349    	LDA	RWFLG2		;GET THE READ/WRITE FLAG
 459C 3C        	INR	A		;ADD ONE
 459D CAB645    	JZ	NEXTE5		;IF IT WAS FF THEN RETURN
 45A0 CD2445    	CALL	MAKE		;MAKE A NEW FILE DIRECTORY ENTRY
 45A3 CDF541    	CALL	CHKCNT		;WAS IT OK
 45A6 CAB645    	JZ	NEXTE5		;IF NOT SET UP EXIT ROUTINE
 45A9 C3AF45    	JMP	NEXTE4		;OTHERWISE SET UP EXTENT POINTERS AND RETURN
                ;
 45AC CD5A44    NEXTE3:	CALL	OPEN1		;GO OPEN THE NEXT EXTENT
 45AF CDBB40    NEXTE4:	CALL	FIXEXT		;SET THE POINTERS UP
 45B2 AF        	XRA	A		;ZERO A FOR THE RETURN
 45B3 C3013F    	JMP	GOBAK		;AND GO BACK
                ;
 45B6 CD053F    NEXTE5:	CALL	JR1		;SET TO RETURN WITH PROBLEMS
 45B9 C37841    	JMP	SETS28		;SET BIT 7 OF S2 TO SAY SO
                ;
                ;******************************************************************************
                ;ROUTINE TO READ THE DISK
                ;
 45BC 3E01      DSKRED:	MVI	A,01H		;GET A !
 45BE 32D549    	STA	DCODE		;SAVE IT FOR THE DISK CODE BYTE
 45C1 3EFF      RRERR:	MVI	A,0FFH		;GET A READ FLAG
 45C3 32D349    	STA	RWFLG2		;SET IT IN FOR THE CONTROL
 45C6 CDBB40    	CALL	FIXEXT		;GO FIX THE EXTENT
 45C9 3AE349    	LDA	ESCNT2		;GET THE EXTENT LOW BYTE
 45CC 21E149    	LXI	H,RECCNT	;POINT TO THE RECORD COUNT
 45CF BE        	CMP	M		;ARE THEY THE SAME?
 45D0 DAE645    	JC	DSKR1		;IF RECORD COUNT WAS BIGGER, JUMP OVER
 45D3 FE80      	CPI	80H		;WAS THE COUNT 80 HEX?
 45D5 C2FB45    	JNZ	DERR		;IF NOT JUMP OUT WITH AN ERROR
 45D8 CD5A45    	CALL	NEXTEX		;GO GET THE NEXT EXTENT
 45DB AF        	XRA	A		;SET A=0
 45DC 32E349    	STA	ESCNT2		;SAVE THIS AS THE NEW EXTENT LOW BYTE
 45DF 3A453F    	LDA	ODATA		;GET THE OUTPUT DATA
 45E2 B7        	ORA	A		;SET THE FLAGS
 45E3 C2FB45    	JNZ	DERR		;IF IT WAS NOT ZERO EXIT WITH ERROR
 45E6 CD7740    DSKR1:	CALL	SECGRP		;OTHERWISE GROUP FROM THE SECTOR COUNT
 45E9 CD8440    	CALL	TSTGRP		;SEE IF IT IS OK
 45EC CAFB45    	JZ	DERR		;IF NOT GO BACK
 45EF CD8A40    	CALL	COMSEC		;IF CO COMPUTE THE RIGHT SECTOR
 45F2 CDD13F    	CALL	GETD1		;GET THE DIRECTORY SET RIGHT
 45F5 CDB23F    	CALL	RDSEC		;READ THE SECTOR
 45F8 C3D240    	JMP	FIXREC		;FIX UP THE RECORD AND RETURN
                ;
 45FB C3053F    DERR:	JMP	JR1		;SET THE ERROR EXIT AND RETURN
                ;
                ;******************************************************************************
                ;ROUTINE TO WRITE THE DISK
                ;
 45FE 3E01      DSKWRT:	MVI	A,01H		;SET THE DISK
 4600 32D549    	STA	DCODE		;   CODE UP
 4603 3E00      RWERR:	MVI	A,0		;SET THE READ WRITE FLAG FOR WRITE
 4605 32D349    	STA	RWFLG2		;AND SAVE IT FOR LATER
 4608 CD5441    	CALL	ROCHK		;SEE IF THE DRIVE IS PROTECTED
 460B 2A433F    	LHLD	FCB		;GET THE FCB ADDRESS
 460E CD4741    	CALL	CHKFR1		;SEE IF THE FILE IS READ ONLY
 4611 CDBB40    	CALL	FIXEXT		;FIX UP THE EXTENT
 4614 3AE349    	LDA	ESCNT2		;AND GET THE LOW EXTENT BYTE
 4617 FE80      	CPI	80H		;IS IT GREATER THAT 80H
 4619 D2053F    	JNC	JR1		;IF SO EXIT WITH ERRORS
 461C CD7740    	CALL	SECGRP		;COMPUTE THE RIGHT GROUP
 461F CD8440    	CALL	TSTGRP		;SEE IF IT IS OK
 4622 0E00      	MVI	C,0		;GET A ZERO
 4624 C26E46    	JNZ	DSKW05		;IF OK JUMP OVER
 4627 CD3E40    	CALL	COMBLK		;COMPUTE THE BLOCK
 462A 32D749    	STA	EXTBLK		;SAVE IT AT EXTENT BLOCK AREA 
 462D 010000    	LXI	B,0		;GET A 16 BIT 0
 4630 B7        	ORA	A		;SET FLAGS
 4631 CA3B46    	JZ	DSKW01		;IF ZERO JUMP OVER
 4634 4F        	MOV	C,A		;
 4635 0B        	DCX	B		;
 4636 CD5E40    	CALL	GETGRP		;GET THE GROUP COUNTER OUT
 4639 44        	MOV	B,H		;SAVE IT
 463A 4D        	MOV	C,L		;  IN BC
 463B CDBE43    DSKW01:	CALL	BLKAVL		;SEE IF A BLOCK IS AVAILABLE
 463E 7D        	MOV	A,L		;CHECK FOR 
 463F B4        	ORA	H		;  ZERO RETURNED
 4640 C24846    	JNZ	DSKW02		;IF NOT ZERO JUMP OVER
 4643 3E02      	MVI	A,02H		;SET THE DISK FULL MESSAGE
 4645 C3013F    	JMP	GOBAK		;AND RETURN
                ;
 4648 22E549    DSKW02:	SHLD	GROUP		;SAVE THE GROUP COUNTER
 464B EB        	XCHG			;PUT IT INTI DE AS WELL
 464C 2A433F    	LHLD	FCB		;GET THE FCB ADDRESS
 464F 011000    	LXI	B,16		;SET THE OFFSET TO THE RECORD COUNT
 4652 09        	DAD	B		;AND POINT TO IT
 4653 3ADD49    	LDA	BSIZE		;GET THE BLOCK SIZE
 4656 B7        	ORA	A		;IS IT ZERO
 4657 3AD749    	LDA	EXTBLK		;GET THE EXTENT BLOCK OUT
 465A CA6446    	JZ	DSKW03		;IF BLOCKS ARE GREATER THAN 1024 JUMP
 465D CD6441    	CALL	PNTD1		;POINT TO THE DIRECTORY ENTRY
 4660 73        	MOV	M,E		;SAVE IN THE GROUP LOW BYTE
 4661 C36C46    	JMP	DSKW04		;AND JUMP OVER
                ;
 4664 4F        DSKW03:	MOV	C,A		;SAVE THE EXTBLK BYTE INTO C
 4665 0600      	MVI	B,0		;ZERO OUT B
 4667 09        	DAD	B		;SLIDE THE OFFSET 
 4668 09        	DAD	B		;   RIGHT 2 BITS
 4669 73        	MOV	M,E		;PUT THE GROUP LOW BYTE INTO PLACE
 466A 23        	INX	H		;POINT TO THE HIGH BYTE
 466B 72        	MOV	M,D		;AND PUT THIS IN TOO
 466C 0E02      DSKW04:	MVI	C,02H		;SET THE EXIT CODE
 466E 3A453F    DSKW05:	LDA	ODATA		;AND THE EXIT DATA
 4671 B7        	ORA	A		;SEE IF IT IS ZERO
 4672 C0        	RNZ			;RETURN IF NOT
 4673 C5        	PUSH	B		;OTHERWISE SAVE THE EXTENT BLOCK POINTER
 4674 CD8A40    	CALL	COMSEC		;GO COMPUTE THE SECTOR
 4677 3AD549    	LDA	DCODE		;GET THE DISK CODE OUT
 467A 3D        	DCR	A		;COUNT IT
 467B 3D        	DCR	A		;  DOWN 2
 467C C2BB46    	JNZ	DSKW08		;IF NOT ZERO JUMP OVER
 467F C1        	POP	B		;RECOVER THE BLOCK OFFSET
 4680 C5        	PUSH	B		;SAVE IT AGAIN
 4681 79        	MOV	A,C		;PUT LOW INTO A
 4682 3D        	DCR	A		;DECREMENT IT BY 1
 4683 3D        	DCR	A		;   AND 1 MORE
 4684 C2BB46    	JNZ	DSKW08		;IF NOT ZERO THEN JUMP
 4687 E5        	PUSH	H		;SAVE THE ADDRESS OF THE DIRECTORY GROUP
 4688 2AB949    	LHLD	DTEMP		;GET THE TEMP ADDRESS
 468B 57        	MOV	D,A		;SAVE THE GROUP LOW BYTE INTO D
 468C 77        DSKW06:	MOV	M,A		;AND PUT IT INTO MEMORY
 468D 23        	INX	H		;POINT TO THE HIGH
 468E 14        	INR	D		;ADD ONE TO D
 468F F28C46    	JP	DSKW06		;IF POSITIVE JUMP PAST
 4692 CDE041    	CALL	SETEMP		;SET THE TEMP BUFFER
 4695 2AE749    	LHLD	DIRPNT		;GET THE DIRECTORY POINTER
 4698 0E02      	MVI	C,02H		;PUT A 2 INTO C
 469A 22E549    DSKW07:	SHLD	GROUP		;SAVE THE GROUP POINTER
 469D C5        	PUSH	B		;PUSH THE COUNTER ONTO THE STACK
 469E CDD13F    	CALL	GETD1		;GET THE NEXT DIRECTORY
 46A1 C1        	POP	B		;RECOVER THE GROUP POINTER
 46A2 CDB83F    	CALL	WRSEC		;WRITE THE SECTOR
 46A5 2AE549    	LHLD	GROUP		;GET THE GROUP DATA
 46A8 0E00      	MVI	C,0		;
 46AA 3AC449    	LDA	BLKMSK		;GET THE BLOCK MASK
 46AD 47        	MOV	B,A		;PUT IT INTO B
 46AE A5        	ANA	L		;AND IN L
 46AF B8        	CMP	B		;COMPARE WITH B
 46B0 23        	INX	H		;AND BUMP TO NEXT
 46B1 C29A46    	JNZ	DSKW07		;IF NOT THE SAME JUMP OVER
 46B4 E1        	POP	H		;RECOVER HL
 46B5 22E549    	SHLD	GROUP		;AND SAVE IT AT GROUP
 46B8 CDDA41    	CALL	SETDMA		;SET THE DMA ADDRESS
 46BB CDD13F    DSKW08:	CALL	GETD1		;AND GET THE NEXT DIRECTORY
 46BE C1        	POP	B		;RECOVER BC
 46BF C5        	PUSH	B		;AND SAVE IT AGAIN
 46C0 CDB83F    	CALL	WRSEC		;WRITE THE SECTOR
 46C3 C1        	POP	B		;RESTORE BC AGAIN
 46C4 3AE349    	LDA	ESCNT2		;GET THE EXTENT COUNT LOW BYTE 
 46C7 21E149    	LXI	H,RECCNT	;POINT TO THE RECORD COUNT
 46CA BE        	CMP	M		;ARE THEY THE SAME
 46CB DAD246    	JC	DSKW09		;IF RECCNT>ESCNT2 JUMP
 46CE 77        	MOV	M,A		;OTHERWISE SAVE A NEW RECCNT
 46CF 34        	INR	M		;BUMP POINTER BY ONE
 46D0 0E02      	MVI	C,02H		;GET A 2 TO FORCE FALL THROUGH BELOW
 46D2 0D        DSKW09:	DCR	C		;DECREMENT
 46D3 0D        	DCR	C		;  BY 2
 46D4 C2DF46    	JNZ	DSKW10		;IF NOT ZERO JUMP OVER
 46D7 F5        	PUSH	PSW		;SAVE THE FLAGS
 46D8 CD6941    	CALL	GETS2		;POINT TO S2 BYTE
 46DB E67F      	ANI	7FH		;STRIP OFF BIT 7
 46DD 77        	MOV	M,A		;AND PUT IT BACK THIS WAY
 46DE F1        	POP	PSW		;RECOVER THE FLAGS
 46DF FE7F      DSKW10:	CPI	7FH		;TEST THE BYTE IN A
 46E1 C20047    	JNZ	DSKW12		;IF NOT 7F JUMP OVER
 46E4 3AD549    	LDA	DCODE		;GET THE DISK CODE OUT
 46E7 FE01      	CPI	01H		;IS IT 1
 46E9 C20047    	JNZ	DSKW12		;IF NOT JUMP
 46EC CDD240    	CALL	FIXREC		;IF SO FIX THE RECORD BYTES
 46EF CD5A45    	CALL	NEXTEX		;AND GET THE NEXT EXTENT READY
 46F2 21453F    	LXI	H,ODATA		;POINT TO THE OUTPUT DATA BYTE
 46F5 7E        	MOV	A,M		;PULL IT IN
 46F6 B7        	ORA	A		;CHECK FOR ZERO
 46F7 C2FE46    	JNZ	DSKW11		;IF NOT JUMP
 46FA 3D        	DCR	A		;DECREMENT IT BY ONE IF IT WAS ZERO
 46FB 32E349    	STA	ESCNT2		;AND SAVE THIS AT ESCNT2
 46FE 3600      DSKW11:	MVI	M,0		;ZERO OUT ODATA
 4700 C3D240    DSKW12:	JMP	FIXREC		;FIX THE RECORDS UP AND RETURN
                ;
                ;******************************************************************************
                ;RANDOM FILE ACCESS ROUTINE - C HAS THE CODE FOR ACCESS TYPE
                ;     FF FOR READ, 0 FOR WRITE
                ; 
 4703 AF        RANFIL:	XRA	A		;ZERO THE DCODE 
 4704 32D549    	STA	DCODE		;   BYTE
 4707 C5        RANF1:	PUSH	B		;SAVE THE ENTRY CODE IN C
 4708 2A433F    	LHLD	FCB		;POINT TO THE FCB ADDRESS
 470B EB        	XCHG			;AND SAVE IT IN DE FOR LATER
 470C 212100    	LXI	H,33		;GET THE OFFSET TO R0
 470F 19        	DAD	D		;POINTING TO R0 BYTE
 4710 7E        	MOV	A,M		;PULL IT IN
 4711 E67F      	ANI	7FH		;AND STRIP OFF THE SECTOR COUNT FOR THIS EXT
 4713 F5        	PUSH	PSW		;SAVE IT ON THE STACK
 4714 7E        	MOV	A,M		;GET R0 AGAIN
 4715 17        	RAL			;SLIDE IT LEFT
 4716 23        	INX	H		;POINT TO R1
 4717 7E        	MOV	A,M		;PULL THIS IN
 4718 17        	RAL			;ROTATE THIS LEFT ALSO PULLING IN BIT 7 OF R0 
 4719 E61F      	ANI	1FH		;STRIP OFF THE LOW 5 BITS FOR EXTENT COUNT
 471B 4F        	MOV	C,A		;SAVE THIS IN C
 471C 7E        	MOV	A,M		;GET R1 AGAIN
 471D 1F        	RAR			;ROTATE
 471E 1F        	RAR			;   IT
 471F 1F        	RAR			;     RIGHT
 4720 1F        	RAR			;       4 BITS
 4721 E60F      	ANI	0FH		;AND MASK OFF THE BLOCK COUNTER
 4723 47        	MOV	B,A		;PUT IT INTO B
 4724 F1        	POP	PSW		;A HAS RECORD, B HAS BLOCK, C HAS EXTENT 
                				;   (0-127)      (0-15)       (0-31)
 4725 23        	INX	H		;POINT TO THE OVERFLOW BYTE
 4726 6E        	MOV	L,M		;PULL IT INTO L
 4727 2C        	INR	L		;ADD ONE
 4728 2D        	DCR	L		;THEN SUB 1 TO SET FLAG 
 4729 2E06      	MVI	L,06H		;GET SEEK PAST END OF DISK ERROR
 472B C28B47    	JNZ	RANF5		;IF NOT ZERO EXIT WITH ERROR
 472E 212000    	LXI	H,32		;OFFSET TO CURRENT RECORD
 4731 19        	DAD	D		;POINT TO IT
 4732 77        	MOV	M,A		;PUT THE CURRENT RECORD BYTE INTO PLACE
 4733 210C00    	LXI	H,12		;NOW GET THE 
 4736 19        	DAD	D		;   EXTENT POINTER
 4737 79        	MOV	A,C		;PULL THE NEW ONE INTO A
 4738 96        	SUB	M		;COMPARE WITH THE ONE WE ARE LOOKING AT
 4739 C24747    	JNZ	RANF2		;IF NOT RIGHT, JUMP OVER
 473C 210E00    	LXI	H,14		;OTHERWISE CHECK THE
 473F 19        	DAD	D		;   S2 BYTE
 4740 78        	MOV	A,B		;PUT THE NEW BLOCK INTO A
 4741 96        	SUB	M		;AND COMPARE WITH WHAT IS THERE 
 4742 E67F      	ANI	7FH		;STRIP OFF BIT 7 FOR THE CHECK
 4744 CA7F47    	JZ	RANF3		;IF ALL IS WELL JUMP BACK
 4747 C5        RANF2:	PUSH	B		;OTHERWISE SAVE THE COUNTERS
 4748 D5        	PUSH	D		;AND THE FCB ADDRESS
 4749 CDA244    	CALL	CLOSEF		;AND CLOSE THE CURRENT EXTENT
 474C D1        	POP	D		;RECOVER THE FCB ADDRESS
 474D C1        	POP	B		;AND THE COUNTERS
 474E 2E03      	MVI	L,03H		;SET THE CLOSE ERROR MESSAGE
 4750 3A453F    	LDA	ODATA		;CHECK THE RESULT
 4753 3C        	INR	A		;  SHOULD BE >0 IF OK
 4754 CA8447    	JZ	RANF4		;IF NOT WE HAD PROBLEMS SO GO BACK
 4757 210C00    	LXI	H,12		;POINT TO
 475A 19        	DAD	D		;  THE EXTENT BYTE
 475B 71        	MOV	M,C		;PUT IN THE NEW VALUE
 475C 210E00    	LXI	H,14		;NOW POINT TO 
 475F 19        	DAD	D		;  THE S2 BYTE
 4760 70        	MOV	M,B		;PUT THE NEW BLOCK IN PLACE
 4761 CD5144    	CALL	OPENF		;GO OPEN THE NEW EXTENT
 4764 3A453F    	LDA	ODATA		;GET THE RESULT
 4767 3C        	INR	A		;AND CHECK IF OK
 4768 C27F47    	JNZ	RANF3		;IF NON ZERO THE OPEN WAS OK SO GO BACK
 476B C1        	POP	B		;RECOVER THE ENTRY CODE
 476C C5        	PUSH	B		;THEN RESAVE IT
 476D 2E04      	MVI	L,04H		;SET THE SEEK TO UNWRITTEN DATA ERROR
 476F 0C        	INR	C		;BUMP THE ENTRY CODE 1
 4770 CA8447    	JZ	RANF4		;IF IT IS ZERO WE EXIT WITH THE ERROR
 4773 CD2445    	CALL	MAKE		;OTHERWISE WE ARE WRITING SO OPEN NEW EXTENT
 4776 2E05      	MVI	L,05H		;GET THE DIRECTORY OVERFLOW ERROR
 4778 3A453F    	LDA	ODATA		;GET THE RESULT
 477B 3C        	INR	A		;ADD ONE TO CHECK
 477C CA8447    	JZ	RANF4		;IF ERRORS EXIT 
 477F C1        RANF3:	POP	B		;OTHERWISE RESTORE THE ENTRY CODE
 4780 AF        	XRA	A		;SET ZERO INTO A
 4781 C3013F    	JMP	GOBAK		;AND RETURN WITH FCB SET RIGHT
                ;
 4784 E5        RANF4:	PUSH	H		;SAVE THE CURRENT ERROR BYTE IN L
 4785 CD6941    	CALL	GETS2		;POINT TO THE S2 BYTE
 4788 36C0      	MVI	M,0C0H		;SET IN A C0 HEX
 478A E1        	POP	H		;RECOVER THE ERROR BYTE
 478B C1        RANF5:	POP	B		;RECOVER THE ENTRY CODE
 478C 7D        	MOV	A,L		;SET THE ERROR BYTE INTO A
 478D 32453F    	STA	ODATA		;SAVE IT FOR THE EXIT
 4790 C37841    	JMP	SETS28		;SET BIT 7 OF S2 FOR LATER
                ;
                ;******************************************************************************
                ;ROUTINE TO READ RANDOM RECORD
                ;
 4793 0EFF      RDREC:	MVI	C,0FFH		;SET THE CODE FOR READING
 4795 CD0347    	CALL	RANFIL		;CALL THE RANDOM ROUTINE TO FIX FCB UP
 4798 CCC145    	CZ	RRERR		;IF OK THEN READ THE RECORD	
 479B C9        	RET			;AND RETURN
                ;
                ;******************************************************************************
                ;ROUTINE TO WRITE RANDOM RECORD
                ;
 479C 0E00      WRREC:	MVI	C,0		;SET THE CODE FOR WRITING
 479E CD0347    	CALL	RANFIL		;GO FIX THE FCB UP
 47A1 CC0346    	CZ	RWERR		;IF OK THEN WRITE THE SECTOR
 47A4 C9        	RET			;AND RETURN
                ;
                ;******************************************************************************
                ;ROUTINE COMPUTES RECORD COUNT FOR RANDOM ACCESS
                ;
 47A5 EB        COMREC:	XCHG			;PUT THE FCB INTO DE - OFFSET INTO HL
 47A6 19        	DAD	D		;SET THE POINTER TO THE RECORD BYTE
 47A7 4E        	MOV	C,M		;PULL THE RECORD COUNT INTO C
 47A8 0600      	MVI	B,0		;ZERO OUT B
 47AA 210C00    	LXI	H,12		;NOW SET OFFSET
 47AD 19        	DAD	D		;  TO POINT TO THE EXTENT BYTE
 47AE 7E        	MOV	A,M		;PULL IT INTO A
 47AF 0F        	RRC			;SLIDE RIGHT THROUGH CARRY - CARRY HAS BIT0
 47B0 E680      	ANI	80H		;STRIP ALL BUT THE BIT IN 7
 47B2 81        	ADD	C		;ADD IN THE CURRENT RECORD COUNT
 47B3 4F        	MOV	C,A		;AND SAVE THIS IN C
 47B4 3E00      	MVI	A,0		;ZERO A LEAVING CARRY SET
 47B6 88        	ADC	B		;ADD IN THE CARRY AND ZERO IN B
 47B7 47        	MOV	B,A		;SAVE THIS IN B 
 47B8 7E        	MOV	A,M		;GET THE EXTENT BYTE AGAIN
 47B9 0F        	RRC			;SLIDE RIGHT THROUGH CARRY
 47BA E60F      	ANI	0FH		;MASK ALL BUT LOW FOUR
 47BC 80        	ADD	B		;ADD IN THE DATA IN B
 47BD 47        	MOV	B,A		;AND SAVE BACK INTO B 
 47BE 210E00    	LXI	H,14		;SET THE POINTER
 47C1 19        	DAD	D		;  TO THE S2 BYTE
 47C2 7E        	MOV	A,M		;PULL IT INTO A
 47C3 87        	ADD	A		;AND SLIDE
 47C4 87        	ADD	A		;   IT
 47C5 87        	ADD	A		;    LEFT
 47C6 87        	ADD	A		;     FOUR BITS
 47C7 F5        	PUSH	PSW		;SAVE THE RESULT ON THE STACK
 47C8 80        	ADD	B		;ADD IN B, IF S2>=16 AND B=17 CARRY IS SET
 47C9 47        	MOV	B,A		;SAVE THE RESULT INTO B
 47CA F5        	PUSH	PSW		;SAVE THE FLAGS AND A
 47CB E1        	POP	H		;PULL FLAGS INTO L
 47CC 7D        	MOV	A,L		;PUT THEN INTO A
 47CD E1        	POP	H		;RECOVER THE SECOND FLAG SET INTO L
 47CE B5        	ORA	L		;OR THE TWO TOGETHER
 47CF E601      	ANI	01H		;AND STRIP OFF ALL BUT CARRY
 47D1 C9        	RET			;THEN RETURN
                ;
                ;******************************************************************************
                ;ROUTINE GETS THE RECORD COUNT FROM THE LAST EXTENT OF A RANDOM FILE
                ;
 47D2 0E0C      GETSIZ:	MVI	C,0CH		;LOOK AT FILE NAME ANT EXTENT
 47D4 CD1843    	CALL	SEARCH		;GO LOCATE THE FILE
 47D7 2A433F    	LHLD	FCB		;POINT TO THE FCB
 47DA 112100    	LXI	D,33		;GET THE OFFSET TO THE
 47DD 19        	DAD	D		;   R0 BYTE
 47DE E5        	PUSH	H		;SAVE THE ADDRESS ON THE STACK
 47DF 72        	MOV	M,D		;PUT THE 0 INTO POSITION
 47E0 23        	INX	H		;POINT TO R1
 47E1 72        	MOV	M,D		;0 GOES THERE AS WELL
 47E2 23        	INX	H		;POINT TO R2 - OVERFLOW BYTE
 47E3 72        	MOV	M,D		;ONCE MORE WITH ZERO
 47E4 CDF541    GSLOOP:	CALL	CHKCNT		;CHECK THE COUNTER
 47E7 CA0C48    	JZ	GSEXIT		;IF ZERO WE EXIT NOW
 47EA CD5E41    	CALL	PNTDIR		;OTHERWISE POINT TO THE DIRECTORY
 47ED 110F00    	LXI	D,15		;GET THE OFFSET TO EXTENT BYTE 
 47F0 CDA547    	CALL	COMREC		;CHECK EXTENT OVERFLOW
 47F3 E1        	POP	H		;RECOVER THE R0 ADDRESS
 47F4 E5        	PUSH	H		;SAVE IT AGAIN
 47F5 5F        	MOV	E,A		;SAVE THE DIRECTORY CODE IN E
 47F6 79        	MOV	A,C		;AND PUT THE R0 BYTE INTO A 
 47F7 96        	SUB	M		;SUBTRACT THE BYTE FROM THE FCB
 47F8 23        	INX	H		;POINT TO THE R1 BYTE 
 47F9 78        	MOV	A,B		;PUT B IN A
 47FA 9E        	SBB	M		;SUBTRACT WITH BORROW FROM HERE AS WELL
 47FB 23        	INX	H		;ONCE MORE WITH THE OVERFLOW BYTE
 47FC 7B        	MOV	A,E		;E INTO A 
 47FD 9E        	SBB	M		;SUBTRACT THE OVERFLOW
 47FE DA0648    	JC	GETSZ1		;IF CARRY JUMP OVER - FILE IS TOO BIG
 4801 73        	MOV	M,E		;PUT R2 INTO PLACE
 4802 2B        	DCX	H		;POINT BACK
 4803 70        	MOV	M,B		;SET R1 IN AS WELL
 4804 2B        	DCX	H		;BACK AGAIN
 4805 71        	MOV	M,C		;AND SET R0 INTO PLACE
 4806 CD2D43    GETSZ1:	CALL	SERCHN		;GO LOOK FOR NEXT EXTENT
 4809 C3E447    	JMP	GSLOOP		;LOOP UNTIL WE HIT THE END
                ;
 480C E1        GSEXIT:	POP	H		;RECOVER THE ADDRESS OF RANDOM FILE SIZE
 480D C9        	RET			;AND RETURN WITH IT
                ;
                ;******************************************************************************
                ; BDOS FUNCTION 36 - SET RANDOM RECORD WITH DATA SET BY RANFIL
                ;
 480E 2A433F    SETRND:	LHLD	FCB		;GET THE FCB ADDRESS
 4811 112000    	LXI	D,32		;AND THE OFFSET TO THE RECORD COUNT
 4814 CDA547    	CALL	COMREC		;GET THE FILE POINTERS INTO A B AND C
 4817 212100    	LXI	H,33		;OFFSET TO THE R0 BYTE
 481A 19        	DAD	D		;POINT TO IT
 481B 71        	MOV	M,C		;PUT THE BYTE IN C INTO R0
 481C 23        	INX	H		;POINT TO R1
 481D 70        	MOV	M,B		;PUT B IN THERE
 481E 23        	INX	H		;POINT TO OVERFLOW BYTE
 481F 77        	MOV	M,A		;STUFF A THERE
 4820 C9        	RET			;AND RETURN
                ;
                ;******************************************************************************
                ;ROUTINE TO LOG THE SELECTED DISK
                ;
 4821 2AAF49    LOGDSK:	LHLD	DLOG		;POINT TO THE LOGIN VECTOR
 4824 3A423F    	LDA	CURDSK		;GET THE CURRENT DISK BYTE
 4827 4F        	MOV	C,A		;AND PUT IT INTO C
 4828 CDEA40    	CALL	SPINHL		;SPIN THE SELECTED DISK BIT INTO PLACE
 482B E5        	PUSH	H		;SAVE THIS VECTOR ON THE STACK
 482C EB        	XCHG			;CAREFUL STUDY SAYS THIS IS USELESS
 482D CD593F    	CALL	DISKID		;GO GET THE DISK INFORMATION SET
 4830 E1        	POP	H		;RECOVER THE VECTOR
 4831 CC473F    	CZ	PTSERR		;IF TROUBLE SAY SO AND QUIT
 4834 7D        	MOV	A,L		;OTHERWISE PUT THE LOW BYTE INTO A 
 4835 1F        	RAR			;SLIDE IT RIGHT BIT 0 INTO CARRY
 4836 D8        	RC			;RETURN IF BIT WAS SET - WE ALREADY GOT IT
 4837 2AAF49    	LHLD	DLOG		;OTHERWISE POINT TO THE LOGIN VECTOR
 483A 4D        	MOV	C,L		;PUT THE VECTOR
 483B 44        	MOV	B,H		;   INTO BC
 483C CD0B41    	CALL	SETDBT		;SET THE DISK BIT USING SETRO
 483F 22AF49    	SHLD	DLOG		;SAVE THE VECTOR INTO PLACE AGAIN
 4842 C3A342    	JMP	GETAL		;GET THE NEW ALLOCATION VECTOR
                ;
                ;******************************************************************************
                ; BDOS FUNCTION 14: SELECT DISK
                ;	ENTER WITH SELECTED DISK IN IDATA
                ;
 4845 3AD649    LOGIN:	LDA	IDATA		;GET THE DISK TO LOG
 4848 21423F    	LXI	H,CURDSK	;POINT TO THE CURRENT DISK STORAGE
 484B BE        	CMP	M		;ARE THEY THE SAME
 484C C8        	RZ			;RETURN IF SO
 484D 77        	MOV	M,A		;OTHERWISE MAKE THIS CURRENT
 484E C32148    	JMP	LOGDSK		;AND LOG IT IN THEN RETURN
                ;
                ;******************************************************************************
                ;ROUTINE TO SELECT DISK INDICATED IN FCB DRIVE CODE
                ;
 4851 3EFF      RSELCT:	MVI	A,0FFH		;GET AN FF
 4853 32DE49    	STA	OUT1		;SAVE IT TO FORCE DISK RESET ON EXIT
 4856 2A433F    	LHLD	FCB		;POINT TO THE FCB
 4859 7E        	MOV	A,M		;PULL IN THE NEW DRIVE CODE
 485A E61F      	ANI	1FH		;STRIP OFF THE USER BITS
 485C 3D        	DCR	A		;DECREMENT TO MAKE IT RIGHT
 485D 32D649    	STA	IDATA		;SAVE IT FOR THE LOGIN ROUTINES
 4860 FE1E      	CPI	1EH		;IS IT TOO BIG
 4862 D27548    	JNC	XIT		;IF SO GO BACK
 4865 3A423F    	LDA	CURDSK		;GET THE CURRENT DISK OUT
 4868 32DF49    	STA	OUTDSK		;SAVE IT FOR THE RETURN
 486B 7E        	MOV	A,M		;PULL IN THE NEW CODE AGAIN
 486C 32E049    	STA	OLDDSK		;SAVE THE VALUE AS THE OLDDISK
 486F E6E0      	ANI	0E0H		;STRIP OFF THE DRIVE BITS
 4871 77        	MOV	M,A		;PUT THE USER BITS BACK
 4872 CD4548    	CALL	LOGIN		;GO LOG THE NEW DISK
 4875 3A413F    XIT:	LDA	USRCOD		;GET THE USER CODE OUT
 4878 2A433F    	LHLD	FCB		;POINT BACK TO THE FCB
 487B B6        	ORA	M		;SET IN THE NEW USER CODE BITS
 487C 77        	MOV	M,A		;AND PUT THE RESULT BACK
 487D C9        	RET			;THEN RETURN
                ;
                ;******************************************************************************
                ;BDOS FUNCTION 12: ROUTINE RETURNS CP/M VERSION IN A
                ;
 487E 3E22      GETVER:	MVI	A,22H		;SAY THIS IS CP/M VERSION 2.2
 4880 C3013F    	JMP	GOBAK		;AND RETURN
                ;
                ;******************************************************************************
                ; BDOS FUNCTION 13: ROUTINE TO RESET THE SYSTEM DISK
                ;
 4883 210000    RESET:	LXI	H,0		;GET READY TO RESET THE VECTORS
 4886 22AD49    	SHLD	ROVEC		;SET BOTH READ ONLY BITS
 4889 22AF49    	SHLD	DLOG		;   AND LOGIN BITS TO OFF
 488C AF        	XRA	A		;ZERO A
 488D 32423F    	STA	CURDSK		;  AND MAKE IT THE CURRENT DISK
 4890 218000    	LXI	H,TBUFF		;SET DMA ADDR TO 80H
 4893 22B149    	SHLD	DMAADR		;SAVE THIS AS THE NEW DMA VALUE
 4896 CDDA41    	CALL	SETDMA		;MAKE IT SO FOR REAL
 4899 C32148    	JMP	LOGDSK		;GO LOG IN DRIVE A AND RETURN
                ;
                ;******************************************************************************
                ; BDOS FUNCTION 15: OPEN FILE
                ;	ENTER WITH FCB ADDRESS IN HL AND INFO 
                ;	EXIT WITH DIRECTORY CODE IN A
                ; 
 489C CD7241    OPEN:	CALL	ZS2		;SET S2 TO ZERO FOR THE NEW FILE
 489F CD5148    	CALL	RSELCT		;SELECT THE RIGHT DISK
 48A2 C35144    	JMP	OPENF		;THEN OPEN THE FILE IN THE FCB
                ;
                ;******************************************************************************
                ; BDOS FUNCTION 16: CLOSE THE SELECTED FILE
                ;	ENTER WITH FCB ADDRESS
                ;	EXIT WITH DIRECTORY CODE IN A
                ;
 48A5 CD5148    CLOSE:	CALL	RSELCT		;SELECT THE RIGHT DRIVE
 48A8 C3A244    	JMP	CLOSEF		;AND FINISH OFF THE CLOSE OPERATION
                ;
                ;******************************************************************************
                ; BDOS FUNCTION 17: SEARCH FOR FIRST FILE ENTRY
                ;	ENTER WITH FCB ADDRESS
                ;	EXIT WITH DIRECTORY CODE IN A	
                ;
 48AB 0E00      SEAR1:	MVI	C,0		;SET THE SEARCH CODE INTO C
 48AD EB        	XCHG			;SWAP FCB INTO DE
 48AE 7E        	MOV	A,M		;PULL IN THE FILE NAME BYTE
 48AF FE3F      	CPI	'?'		;IS IT A WILD CARD
 48B1 CAC248    	JZ	SRF2		;IF SO JUMP OVER
 48B4 CDA640    	CALL	GETEX		;OTHERWISE GET THE EXTENT
 48B7 7E        	MOV	A,M		;PULL IN THE BYTE HERE
 48B8 FE3F      	CPI	'?'		;IS IT A WILD CARD
 48BA C47241    	CNZ	ZS2		;IF NOT SET S2 TO 0
 48BD CD5148    	CALL	RSELCT		;SELECT THE RIGHT DRIVE
 48C0 0E0F      	MVI	C,0FH		;LOOK AT NAME THRU S2 BYTE
 48C2 CD1843    SRF2:	CALL	SEARCH		;SEARCH FOR THE FILE
 48C5 C3E941    	JMP	MOVSEC		;JUMP TO MOVE THE SECTOR AND RETURN
                ;
                ;******************************************************************************
                ;BDOS FUNCTION 18: SEARCH FOR NEXT DIRECTORY ENTRY
                ;	ENTER WITH FCB SET AS BEFORE
                ;	EXIT WITH DIRECTORY CODE IN A 255 SAYS NOT FOUND
                ;
 48C8 2AD949    SEARN:	LHLD	SEARA		;GET THE LAST SEARCH FCB OUT
 48CB 22433F    	SHLD	FCB		;SAVE THIS AS THE FCB
 48CE CD5148    	CALL	RSELCT		;SELECT THE RIGHT DRIVE
 48D1 CD2D43    	CALL	SERCHN		;THEN SEARCH FOR THE NEX EXTENT
 48D4 C3E941    	JMP	MOVSEC		;MOVE THE SECTOR AND RETURN
                ;
                ;******************************************************************************
                ; BDOS FUNCTION 19: DELETE FILE
                ;	ENTER WITH FCB ADDRESS SET
                ;	EXIT WITH DIRECTORY CODE IN A
                ;
 48D7 CD5148    DELETE:	CALL	RSELCT		;SELECT THE RIGHT DRIVE
 48DA CD9C43    	CALL	DELETF		;DELETE THE INDICATED FILE
 48DD C30143    	JMP	RETCOD		;SET THE RETURN CODE AND GO BACK
                ;
                ;******************************************************************************
                ; BDOS FUNCTION 20: READ SEQUENTIAL
                ;	ENTER WITH FCB ADDRESS
                ;	EXIT WITH DIRECTORY CODE IN A
                ;
 48E0 CD5148    READ:	CALL	RSELCT		;SELECT THE INDICATED DRIVE
 48E3 C3BC45    	JMP	DSKRED		;AND GO READ THE DISK
                ;
                ;******************************************************************************
                ; BDOS FUNCTION 21: WRITE SEQUENTIAL
                ;	ENTER WITH FCB ADDRESS
                ;	EXIT WITH DIRECTORY CODE IN A
                ;
 48E6 CD5148    WRITE:	CALL	RSELCT		;SELECT THE DRIVE
 48E9 C3FE45    	JMP	DSKWRT		;AND GO WRITE THE DISK
                ;
                ;******************************************************************************
                ; BDOS FUNCTION 22: MAKE NEW FILE ENTRY
                ;	ENTER WITH FCB
                ;	EXIT WITH DIRECTORY CODE IN A
                ;
 48EC CD7241    CREATE:	CALL	ZS2		;ZERO OUT S2
 48EF CD5148    	CALL	RSELCT		;SELECT THE DRIVE
 48F2 C32445    	JMP	MAKE		;AND MAKE A NEW DIRECTORY ENTRY
                ;
                ;******************************************************************************
                ; BDOS FUNCTION 23: RENAME FILE
                ;	ENTER WITH FCB ADDRESS
                ;	EXIT WITH DIRECTORY CODE IN A
                ;
 48F5 CD5148    RENAME:	CALL	RSELCT		;SELECT THE DRIVE
 48F8 CD1644    	CALL	RENAMF		;AND GO RENAME THE FILE
 48FB C30143    	JMP	RETCOD		;SET THE RETURN CODE AND EXIT
                ;
                ;******************************************************************************
                ; BDOS FUNCTION 24: RETURN LOGIN VECTOR
                ;	EXIT WITH LOGIN VECTOR IN HL
                ;
 48FE 2AAF49    GLOGIN:	LHLD	DLOG		;GET THE LOGIN VECTOR OUT
 4901 C32949    	JMP	RETHL		;RETURN WITH IT
                ;
                ;******************************************************************************
                ; BDOS FUNCTION 25: RETURN CURRENT DISK
                ;	EXIT WITH CURRENT DISK IN A
                ;
 4904 3A423F    GETDRV:	LDA	CURDSK		;GET THE CURRENT DISK OUT
 4907 C3013F    	JMP	GOBAK		;AND GO BACK WITH IT
                ;
                ;******************************************************************************
                ; BDOS FUNCTION 26: SET DMA ADDRESS
                ;	ENTER WITH DMA ADDRESS SET
                ;
 490A EB        DMASET:	XCHG			;SAVE THE NEW ADDRESS INTO HL
 490B 22B149    	SHLD	DMAADR		;SAVE IT INTO PLACE
 490E C3DA41    	JMP	SETDMA		;THEN MAKE IT TRUE
                ;
                ;******************************************************************************
                ; BDOS FUNCTION 27: GET ALLOCATION VECTOR ADDRESS
                ;	RETURN ADDRESS IN HL
                ;
 4911 2ABF49    GALLOC:	LHLD	ALLOCA		;GET THE ALLOCATION VECTOR OUT
 4914 C32949    	JMP	RETHL		;AND GO BACK WITH IT
                ;
                ;******************************************************************************
                ; BDOS FUNCTION 29: GET READ/ONLY VECTOR
                ;	RETURN VECTOR IN HL
                ;
 4917 2AAD49    GROVEC:	LHLD	ROVEC		;GET THE READ ONLY VECTOR OUT
 491A C32949    	JMP	RETHL		;AND GO BACK WITH IT
                ;
                ;******************************************************************************
                ; BDOS FUNCTION 30: SET FILE ATTRIBUTES
                ;	ENTER WITH FCB ADDRESS WITH NEW ATTRIBUTES SET IN F1..F7,T1..T3
                ;	EXIT WITH DIRECTORY CODE IN A
                ;
 491D CD5148    SETATT:	CALL	RSELCT		;SELECT THE INDICATE DRIVE
 4920 CD3B44    	CALL	SETFN		;SET IN THE NEW FILE NAME WITH BITS SET
 4923 C30143    	JMP	RETCOD		;SET THE RETURN CODE AND EXIT
                ;
                ;******************************************************************************
                ; BDOS FUNCTION 31: GET ADDRESS OF DISK PARAMETER TABLE
                ;	RETURN ADDRESS IN HL
                ;
 4926 2ABB49    GETPAR:	LHLD	DPB		;GET THE DISK PARAMETER TABLE ADDRESS
 4929 22453F    RETHL:	SHLD	ODATA		;SAVE IT AT RETURN DATA WORD
 492C C9        	RET			;AND GO BACK WITH IT
                ;
                ;******************************************************************************
                ; BDOS FUNCTION 32: GET OR SET USER CODE
                ;	ENTER WITH LINFO SET TO FF FOR GET AND TO VALUE FOR SET
                ;
 492D 3AD649    MODUSR:	LDA	IDATA		;GET THE INPUT ARGUMENT
 4930 FEFF      	CPI	0FFH		;DO WE DO A SET
 4932 C23B49    	JNZ	SETCODE		;OR A GET
 4935 3A413F    	LDA	USRCOD		;MUST BE GET SO GET
 4938 C3013F    	JMP	GOBAK		;AND GO BACK WITH IT
                ;
 493B E61F      SETCODE:ANI	1FH		;OTHERWISE STRIP OFF THE HIGH BITS
 493D 32413F    	STA	USRCOD		;AND SAVE THE NEW VALUE
 4940 C9        	RET			;THEN RETURN
                ;
                ;******************************************************************************
                ; BDOS FUNCTION 33: READ RANDOM RECORD
                ;	ENTER WITH FCB ADDRESS
                ;	EXIT WITH RETURN CODE IN A
                ;
 4941 CD5148    REDRND:	CALL	RSELCT		;SELECT THE RIGHT DRIVE
 4944 C39347    	JMP	RDREC		;AND GO READ THE SECTOR
                ;
                ;******************************************************************************
                ; BDOS FUNCTION 34: WRITE RANDOM RECORD
                ;	ENTER WITH FCB ADDRESS
                ;	EXIT WITH RETURN CODE IN A
                ;
 4947 CD5148    WRTRND:	CALL	RSELCT		;GO SELECT THE DRIVE
 494A C39C47    	JMP	WRREC		;AND WRITE THE SECTOR
                ;
                ;******************************************************************************
                ; BDOS FUNCTION 35: COMPUTE FILE SIZE
                ;	ENTER WITH FCB ADDRESS
                ;	EXIT WITH RANDOM RECORD SET IN FCB
                ;
 494D CD5148    FILSIZ:	CALL	RSELCT		;SELECT THE RIGHT DRIVE
 4950 C3D247    	JMP	GETSIZ		;AND COMPUTE THE FILE SIZE
                ;
                ;******************************************************************************
                ; BDOS FUNCTION 37: ROUTINE TO RESET DRIVE
                ;	ENTER WITH DRIVE VECTOR FOR RESET
                ;	RETURN ZERO IN A
                ;
 4953 2A433F    RESDRV:	LHLD	FCB		;HAS THE DRIVE VECTOR FOR RESET
 4956 7D        	MOV	A,L		;MOVE LOW INTO A
 4957 2F        	CMA			;AND FLIP IT
 4958 5F        	MOV	E,A		;PUT THE RESULT BACK INTO E
 4959 7C        	MOV	A,H		;GET THE HIGH VECTOR BYTE
 495A 2F        	CMA			;  FLIP ITR ALSE
 495B 2AAF49    	LHLD	DLOG		;GET THE LOGIN VECTOR
 495E A4        	ANA	H		;AND IN THE NEW BITS IN HIGH
 495F 57        	MOV	D,A		;SAVE THE RESULT INTO D
 4960 7D        	MOV	A,L		;NOW ON THE THE LOW BITS
 4961 A3        	ANA	E		;AND IN THE NEW BITS
 4962 5F        	MOV	E,A		;AND SAVE THE RESULT INTO E
 4963 2AAD49    	LHLD	ROVEC		;POINT TO THE RO VECTOR
 4966 EB        	XCHG			;SWAP DE AND HL
 4967 22AF49    	SHLD	DLOG		;PUT THE NEW LOGIN VECTOR INTO PLACE
 496A 7D        	MOV	A,L		;GET THE READ ONLY LOW BITS
 496B A3        	ANA	E		;AND IN THE NEW BITS
 496C 6F        	MOV	L,A		;PUT THEN BACK INTO L
 496D 7C        	MOV	A,H		;NOW ON THE THE HIGH BITS
 496E A2        	ANA	D		;SET THE NEW ONES IN
 496F 67        	MOV	H,A		;AND PUT THE RESULT BACK
 4970 22AD49    	SHLD	ROVEC		;THEN SAVE THE NEW VALUE INTO PLACE
 4973 C9        	RET			;AND RETURN WHEN DONE
                ;
                ;******************************************************************************
                ; BDOS EXIT ROUTINE
                ;
 4974 3ADE49    BEXIT:	LDA	OUT1		;GET THE OUT FLAG FOR DRIVE RESET
 4977 B7        	ORA	A		;SET THE FLAGS
 4978 CA9149    	JZ	REXIT		;IF ZERO WE MAY EXIT AS IS
 497B 2A433F    	LHLD	FCB		;OTHERWISE GET THE FCB ADDRESS
 497E 3600      	MVI	M,0		;PUT A ZERO INTO DRIVE SELECT BYTE
 4980 3AE049    	LDA	OLDDSK		;GET THE OLD DISK OUT
 4983 B7        	ORA	A		;WAS IT ZERO
 4984 CA9149    	JZ	REXIT		;IF SO EXIT
 4987 77        	MOV	M,A		;OTHERWISE SET IN THE OLD DISK BYTE
 4988 3ADF49    	LDA	OUTDSK		;GET THE DISK TO RELOG
 498B 32D649    	STA	IDATA		;SAVE IT FOR THE LOGIN
 498E CD4548    	CALL	LOGIN		;GO LOG IN THE OLD DISK
 4991 2A0F3F    REXIT:	LHLD	OLDSP		;GET THE OLD STACK POINTER OUT
 4994 F9        	SPHL			;PUT IT BACK IN PLACE
 4995 2A453F    	LHLD	ODATA		;GET THE OUTPUT DATA INTO PLACE
 4998 7D        	MOV	A,L		;PUT L INTO A
 4999 44        	MOV	B,H		;AND H INTO B
 499A C9        	RET			;THEN RETURN FROM BDOS HAPPY
                ;
                ;******************************************************************************
                ; BDOS FUNCTION 40: ROUTINE TO WRITE RANDOM FILE WITH ZERO FILL
                ;	ENTER WITH FCB ADDRESS
                ;	EXIT WITH RETURN CODE IN A
                ;
 499B CD5148    ZERRND:	CALL	RSELCT		;SELECT THE DESIRED DRIVE
 499E 3E02      	MVI	A,2		;GET THE CODE FOR ZERO FILL
 49A0 32D549    	STA	DCODE		;SET IT INTO PLACE
 49A3 0E00      	MVI	C,0		;ZERO C AS WELL
 49A5 CD0747    	CALL	RANF1		;THEN OFF THE FINISH THE JOB SET POINTERS
 49A8 CC0346    	CZ	RWERR		;THEN WRITE THE SECTOR IF ALL IS WELL
 49AB C9        	RET			;AND RETURN
                ;
                ;******************************************************************************
                ;BDOS DATA AREA FOLLOWS
                ;
 49AC E5        TINFO:	DB	0E5H		;
 49AD 0000      ROVEC:	DW	0		;READ ONLY VECTOR ADDRESS STORAGE
 49AF 0000      DLOG:	DW	0		;DISK LOGIN AREAX
 49B1 8000      DMAADR:	DW	0080H		;DMA ADDRESS DEFAULTS TO 80H
 49B3 0000      SCRT0:	DW	0		;
 49B5 0000      SCRT1:	DW	0		;HOLDS CURRENT TRACK
 49B7 0000      SCRT2:	DW	0		;HOLDS STARTING SECTOR NUMBER OF CURRENT TRACK
 49B9 0000      DTEMP:	DW	0		;TEMP DMA ADDRESS STORAGE
 49BB 0000      DPB:	DW	0		;DISK PARAMETER BLOCK ADDRESS
 49BD 0000      CHANGE:	DW	0		;SCRATCH STORAGE FOR DISK CHANGE CHECK
 49BF 0000      ALLOCA:	DW	0		;ALLOCATION VECTOR AREA
 49C1 0000      DPBLK:	DW	0		;DISK PARM BLOCK - NUMBER OF SECTORS/TRK
 49C3 00        BLSHFT:	DB	0		;BLOCK SHIFT FACTOR
 49C4 00        BLKMSK:	DB	0		;BLOCK MASK
 49C5 00        EXTMSK:	DB	0		;NULL MASK
 49C6 0000      DSIZE:	DW	0		;DISK SIZE
 49C8 0000      DIRMAX:	DW	0		;DIRECTORY MAX
 49CA 0000      AL01:	DW	0		;ALLOCATION STORAGE
 49CC 0000      CKSIZE:	DW	0		;NUMBER OF ENTRIES TO CHECK
 49CE 0000      TOFS:	DW	0		;TRACK OFFSET
 49D0 0000      TRANS:	DW	0		;TRANSLATION ROUTINE ADDRESS HOLDER
 49D2 00        RWFLG1:	DB	0		;FLAG INDICATES READ OR WRITE
 49D3 00        RWFLG2:	DB	0		;FLAG ALSO USED TO INDICATE READ OR WRITE
 49D4 00        SCODE1:	DB	0
 49D5 00        DCODE:	DB	0		;DISK CODE BYTE
 49D6 00        IDATA:	DB	0		;INPUT DATA STORAGE AREA
 49D7 00        EXTBLK:	DB	0
 49D8 00        SCODE:	DB	0
 49D9 00        SEARA:	DB	0
 49DA 00        	DB	0
 49DB 00        	DB	0
 49DC 00        	DB	0
 49DD 00        BSIZE:	DB	0		;BLOCK SIZE BYTE
 49DE 00        OUT1:	DB	0		;USED TO FORCE RELOG OF DISK ON EXIT
 49DF 00        OUTDSK:	DB	0		;BDOS EXIT DISK
 49E0 00        OLDDSK:	DB	0		;DISK ENTERED WITH
 49E1 00        RECCNT:	DB	0		;RECORD COUNT HOLDER
 49E2 00        ESCNT1:	DB	0		;EXTENT RECORT COUNT HIGH BYTE
 49E3 00        ESCNT2:	DB	0		;EXTENT RECORD COUNT LOW BYTE
 49E4 00        	DB	0
 49E5 00        GROUP:	DB	0		;GROUP NUMBER STORAGE
 49E6 00        	DB	0
 49E7 00        DIRPNT:	DB	0		;DIRECTORY POINTER AREA
 49E8 00        	DB	0
 49E9 00        DIROFF:	DB	0		;OFFSET INTO THE DIRECTORY AREA
 49EA 00        COUNT:	DB	0		;HOLDS 16 BIT COUNTER FOR LOOPING
 49EB 00        	DB	0
 49EC 00        LDIRPNT:DB	0
 49ED 00000000  	DB	0,0,0,0
 49F1 00000000  	DB	0,0,0,0
 49F5 00000000  	DB	0,0,0,0
 49F9 00000000  	DB	0,0,0,0
 49FD 000000    	DB	0,0,0
                ;
                ; BIOS ENTRY VECTOR DEFINITIONS
                ;
                ; (THESE ARE ACTUALLY IN CBIOS)
                ;
 4A00           	DS	3		;(BOOT) COLD BOOT ENTRY
 4A03           WBOOTF:	DS	3		;WARM BOOT ENTRY
 4A06           CONSF:	DS	3		;CONSOLE STATUS
 4A09           CONIF:	DS	3		;CONSOLE CHAR IN
 4A0C           CONOF:	DS	3		;CONSOLE CHAR OUT
 4A0F           LISTF:	DS	3		;LIST CHAR OUT
 4A12           PUNF:	DS	3		;PUNCH CHAR OUT
 4A15           READF:	DS	3		;READER CHAR IN
 4A18           HOMF:	DS	3		;HOME DISK
 4A1B           SELF:	DS	3		;SELECT DISK
 4A1E           TRKF:	DS	3		;SET DISK TRACK ADDR
 4A21           SECF:	DS	3		;SET DISK SECTOR ADDR
 4A24           DMAF:	DS	3		;SET DMA BUFFER ADDR
 4A27           DRDF:	DS	3		;READ SECTOR
 4A2A           DWRF:	DS	3		;WRITE SECTOR
 4A2D           	DS	3		;
 4A30           SECTRN:	DS	3		;SECTOR TRANSLATION ROUTINE
                ;
 4A33           	END
